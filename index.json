[{"content":"Clace applications implement a Hypermedia driven approach for developing web applications. Applications return HTML fragments as API response using Go html templates. The UI uses HTML enhanced with hypermedia controls using the HTMX library to implement user interactions.\nThe backend API routes and dependencies like CSS library, JavaScript modules etc are configured using Starlark configuration. Any custom API handling required is implemented in handler functions also written in Starlark. Starlark is a subset of python, optimized for application configuration usecases.\nStructure # The structure of a Clace application is:\nOne Clace application per folder, static sub-folder contain static assets An app.star Starlark file, defining the application configuration Predefined builtins, accessed through the ace namespace A global called app, created using app = ace.app() call An optional default handler function called handler. Other handlers are referenced in the route config An html template file called index.go.html if using custom layout If not using custom layout, an html template block called clace_body defined in any *.go.html file, for example app.go.html App Lifecycle # The Clace app development lifecycle is:\nCreate a folder for the app, with the app.star file and templates. Start the Clace server. Create an app using clace app create --is_dev. This runs the app in dev mode. In dev mode, some additional files are generated, with _gen in the file name. CSS dependencies and JavaScript modules are downloaded into the static folder. After the app development is done, the whole app folder can be checked into source control. There is no build step. Create a production app, clace app create, without the --is_dev. The app is now live. The Clace server can host multiple applications, each application has a dedicated path and optionally a dedicated domain. Examples # Simple App # The simplest app, using the default builtin layout would be two files. An app.star file containing\napp = ace.app(\u0026#34;hello1\u0026#34;, pages = [ace.page(\u0026#34;/\u0026#34;)]) and an app.go.html file containing\n{{block \u0026#34;clace_body\u0026#34; .}} Hello World {{end}} Create an app in dev mode with this code and visiting the app url will show Example Output The name of the app is hello1. There is only one route defined, for page /, which shows a HTML page with the name of the app. The body is generated from the contents of the app.go.html file. A more verbose way to write the same app config would be\napp = ace.app(name=\u0026#34;hello1\u0026#34;, custom_layout=False, pages = [ace.page(path=\u0026#34;/\u0026#34;, html=\u0026#34;index_gen.go.html\u0026#34;)] ) index_gen.go.html is the auto generated index file, created when the default builtin layout is used.\nApp with Custom Layout # To create an app with a custom HTML page which shows a listing of files in your root directory, create an app.star file with\nload(\u0026#34;exec.in\u0026#34;, \u0026#34;exec\u0026#34;) def handler(req): ret = exec.run(\u0026#34;ls\u0026#34;, [\u0026#34;-l\u0026#34;, \u0026#34;/\u0026#34;]) return {\u0026#34;Lines\u0026#34;: ret.lines} app = ace.app(\u0026#34;hello1\u0026#34;, custom_layout=True, pages = [ace.page(\u0026#34;/\u0026#34;)], permissions = [ace.permission(\u0026#34;exec.in\u0026#34;, \u0026#34;run\u0026#34;, [\u0026#34;ls\u0026#34;])] ) and an index.go.html file with\n\u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;File List\u0026lt;/title\u0026gt; {{ template \u0026#34;clace_gen_import\u0026#34; . }} \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {{ range .Data.Lines }} {{.}} \u0026lt;br/\u0026gt; {{end}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; This app uses the exec plugin to run a ls command. The output of the command is shown when th app is accessed. To allow the app to run the plugin command, use the clace app audit --approve command.\nMore examples # There are more examples here. The disk_usage example uses the MVP classless library for styling and shows a basic hypermedia flow. The cowbull game examples has multiple pages, each page with some dynamic behavior. Clace does not currently have a persistence layer. The cowbull game depends on another service for data persistence, so it is implementing a backend for frontend pattern. For styling, it uses the DaisyUI component library for Tailwind CSS. These two examples work fine with Javascript disabled in the browser, falling back to basic HTML without any HTMX extensions.\nThe memory_usage example uses the d3 library to show a interactive display of the memory usage for processes on the machine. The plot library is automatically imported as a ECMAScript module and the custom javascript code works with a JSON api on the backend. The default in Clace is hypermedia exchange, JSON can be used for data API\u0026rsquo;s.\n","date":null,"permalink":"/docs/app/overview/","section":"Docs","summary":"Overview of the Clace application development model","title":"Overview"},{"content":"Request Routing # The Clace server can host multiple applications simultaneously. Each application gets a dedicated path, the application can use all sub-paths within that without conflicts with other applications.\nWhen an application is created, a path needs to be specified and a domain can be optionally specified. Routing for application requests is done based on domain and path. The domain is the namespace within which the paths are resolved.\nConsider this scenario:\nApp A is installed at /utils/appA App B is installed at /appB App C is installed at the root level / for domain example.com App D is installed at /test for test.mydomain.com App E is installed at /test2 for test.mydomain.com For every API call, the Clace server first checks whether the API call is against a domain namespace which is currently configured in Clace. If so, applications matching that domain are looked up. If no matching domain is located, then the default namespace (with no domain) is looked up.\nFor the above scenario:\nRequests to /utils/appA/* for any domain other than example.com and test.mydomain.com will go to App A. Requests to /appB/* for any domain other than example.com and test.mydomain.com will go to App B. Requests to example.com for any path will always go to App C, since it is installed at the root path. Requests to test.mydomain.com:/test/* will go to App D. Requests to test.mydomain.com:/test2/* will go to App E. Requests to test.mydomain.com for any path other than /test or /test2 will fail with a 404. Creating Applications # When an app is being created, a path and an optional domain need to be specified. For the above example scenario:\nNo new apps can be created for example.com domain, since App C is installed at the root path. For the test.mydomain.con domain, no new app can be created under /test and /test2, other paths are available. For the default domain, /utils/appA and /appB are taken, other paths are available. New apps can be created under any path, including root path, for new domains and subdomains, like test.example.com. Notes # The domain specified for the app is used only for routing requests. The user has to ensure that the actual DNS routing is done properly outside of Clace for the API calls to land on the Clace server. Using wildcard DNS entries will reduce the work required in the DNS service. So if *.example.com points to the IP address of the Clace service, any domain based routing done in Clace will work with no further DNS configuration being required. The automated certificates created by Clace will be domain level certificates, wildcard certificates are not currently created. /_clace/ at the root level and /_clace_app/ within an app path are reserved paths, they are used by the Clace server, requests will not reach the app. This applies for all domains. ","date":null,"permalink":"/docs/applications/routing/","section":"Docs","summary":"Installing apps and managing request routing across Clace applications, using path and domain","title":"Application Routing"},{"content":"Clace can currently be installed from source. Other installation options will be added soon.\nInstall from Source # To install from source\nEnsure that a recent version of Go is available, version 1.21.0 or newer Checkout the Clace repo, cd to the checked out folder Build the clace binary and place in desired location, like $HOME # Ensure go is in the $PATH mkdir $HOME/clace_source \u0026amp;\u0026amp; cd $HOME/clace_source git clone -b main https://github.com/claceio/clace \u0026amp;\u0026amp; cd clace go build -o $HOME/clace ./cmd/clace/ Initial Configuration # To use the clace service, you need an initial config file with the service password and a work directory. The below instructions assume you are using $HOME/clhome/clace.toml as the config file and $HOME/clhome as the work directory location.\nCreate the clhome directory Create the clace.toml file, and create a randomly generate password for the admin user account export CL_HOME=$HOME/clhome \u0026amp;\u0026amp; mkdir $CL_HOME $HOME/clace password \u0026gt; $CL_HOME/clace.toml This will print a random password on the screen, note that down as the password to use for accessing the applications.\nStart the service # To start the service, the CL_HOME environment variable has to point to the work directory location and the CL_CONFIG_FILE env variable should point to the config file.\nexport CL_HOME=$HOME/clhome export CL_CONFIG_FILE=$CL_HOME/clace.toml $HOME/clace server start Add the exports to your shell profile file to automate this. The service logs will be going to $CL_HOME/logs. To get the logs on the console also, you can add -c -l DEBUG to the server start command.\nThe service will be started on https://localhost:25223 by default.\nRunning the client # The client can be used to install and manage applications. To run the client, the CL_CONFIG_FILE environment variable should be set pointing to the config file export CL_CONFIG_FILE=$HOME/clhome/clace.toml.\nLoad an App # To create an app, run\n$HOME/clace app create --is_dev /disk_usage $HOME/clace_source/clace/examples/disk_usage/ To audit and approve the app\u0026rsquo;s security policies, run\n$HOME/clace app audit --approve /disk_usage This will create an app at /disk_usage with the example disk_usage app. The disk_usage app provides a web interface for the du command, allowing the user to explore the subfolders which are consuming most disk space.\nTo access the app, go to https://127.0.0.1:25223/disk_usage. Use admin as the username and use the password previously generated. Allow the browser to connect to the self-signed certificate page. Or connect to http://127.0.0.1:25222/disk_usage to avoid the certificate related warning.\nThe code for the example app is here. app.star is the starlark config and app.go.html is the html template. The other files are generated files and are created by the system on app initialization.\n","date":null,"permalink":"/docs/installation/","section":"Docs","summary":"How to install Clace and do initial setup","title":"Installation"},{"content":"Clace Server # The Clace server picks up its configuration from the config file specified at startup.\n$ clace server start -h NAME: clace server start - Start the clace server USAGE: clace server start [command options] [arguments...] OPTIONS: --server_uri value, -s value The server connection uri (default: \u0026#34;$CL_HOME/run/clace.sock\u0026#34;) [$CL_SERVER_URI] --admin_user value, -u value The admin user name (default: \u0026#34;admin\u0026#34;) [$CL_ADMIN_USER] --http.host value, -i value The interface to bind on for HTTP (default: \u0026#34;127.0.0.1\u0026#34;) [$CL_HTTP_HOST] --http.port value, -p value The port to listen on for HTTP (default: 25222) [$CL_HTTP_PORT] --https.host value The interface to bind on for HTTPS (default: \u0026#34;0.0.0.0\u0026#34;) [$CL_HTTPS_HOST] --https.port value The port to listen on for HTTPS (default: 25223) [$CL_HTTPS_PORT] --logging.level value, -l value The logging level to use (default: \u0026#34;INFO\u0026#34;) [$CL_LOGGING_LEVEL] --logging.console, -c Enable console logging (default: false) [$CL_LOGGING_CONSOLE] --help, -h show help GLOBAL OPTIONS: --config_file value, -c value TOML configuration file [$CL_CONFIG_FILE] --help, -h show help All the parameters have default values, specified in the code at clace.default.toml.\nA user-specified config file is required. The location of this file can be set using the command line arg --config_file. If CLI arg is not specified, the environment variable CL_CONFIG_FILE is used to locate the config file. There is no default location for this file, if no CLI argument and env value are specified, then no configuration file is loaded.\nAll arguments are read from the user specified configuration file. Some arguments are further configurable in the CLI or env. For example, set --http.host=7777 or env CL_HTTP_PORT to set the http port. The precedence order, from highest priority to lowest is:\nCLI argument ENV variable User specified config Default config in the source code for the Clace build version Home Directory # The CL_HOME environment variable is used to locate the home directory for the Clace server. If no value is set, this defaults to the directory from which the Clace server was started. This location is used to store:\nThe sqlite database containing the metadata information, default is $CL_HOME/clace.db The logs for the service, under the logs folder. The config folder contains the certificates to be use for TLS. The run folder contains app specific temporary files. Clace Client CLI # By default, the Clace client uses Unix domain sockets to connect to the Clace server. The $CL_HOME should point to the same location for server and client. If no changes are done for the server defaults, then the client can connect to the server locally without any other configuration being required. See here for details about the client configuration.\n","date":null,"permalink":"/docs/configuration/overview/","section":"Docs","summary":"Overview of Clace configuration, at the server level and client level and the $CL_HOME location for files","title":"Overview"},{"content":"The request routing layer in Clace is built on top of the chi routing library. The routing is built for hypermedia exchange, so all routes are defined in terms of pages and fragments within the pages. This grouping of requests helps make it clear which API does what and provide an easy mechanism to deal with partial HTMX driven requests and full page refreshes. Simpler application might have one page with some interactions within that. Larger applications can be composed of multiple pages, each page having some interactive fragments.\nPages # The app contains an pages array, which defines all the routes for the app. For example, the app definition\napp = ace.app(\u0026#34;hello1\u0026#34;, pages = [ ace.page(\u0026#34;/\u0026#34;), ace.page(\u0026#34;/help\u0026#34;, \u0026#34;help.go.html\u0026#34;) ] ) defines two routes. / routes to the default index page, /help routes to the help page.\nPage # ace.Page is used to define the properties for a single page. The parameters for ace.page are:\nProperty Optional Type Default Notes path False string The route, should start with a / html True string index.go.html if custom layout, else index_gen.go.html The template to use for full page requests block True string None The template to use for partial page requests handler True function handler (if defined) The handler function to use for the route fragments True ace.fragment[] [] The fragment array method True string GET The HTTP method type: GET,POST,PUT,DELETE etc type True string html The response type, html or json Fragment # The fragments array in the page definition defines the API interactions within the page. The parameters for ace.Fragment are:\nProperty Optional Type Default Notes path False string The route, should not start with a / block True string Inherited from page The template to use for partial requests handler True function Inherited from page The handler function to use for the route method True function GET The HTTP method type: GET,POST,PUT,DELETE etc type True string html The response type, html or json Note: block and handler are inherited from the page level, unless overridden for the fragment. For example, in this page definition\nace.page(\u0026#34;/game/{game_id}\u0026#34;, \u0026#34;game.go.html\u0026#34;, \u0026#34;game_info_tmpl\u0026#34;, handler=game_handler, fragments=[ ace.fragment( \u0026#34;submit\u0026#34;, method=\u0026#34;POST\u0026#34;, handler=lambda req: post_game_update(req, \u0026#34;submit\u0026#34;)), ace.fragment( \u0026#34;refresh\u0026#34;, block=\u0026#34;refresh_tmpl\u0026#34;) ] ) there are three API\u0026rsquo;s defined:\nGET /game/{game_id} : game_handler is the handler function, full page request returns game.go.html, partial HTMX request returns game_info_tmpl template POST /game/{game_id}/submit : The handler is a lambda function. The game_info_tmpl template is inherited from page as the response for the POST. GET /game/{game_id}/refresh : game_handler is inherited from the page. For full page, it returns the game.go.html response, since this is a fragment for that page. For partial HTMX requests, refresh_tmpl template is returned API Flow # The API flow is\nThe API is first sent to the matching app Within the app, the API is routed based on the routes defined If there is a handler defined for the matched route, the handler function is called with the request as argument The response template is invoked, with a input map containing a Data property as returned by the handler function If the API type is set to json, the handler response is directly returned, with no template being used Notes # For HTMX partial requests, the block template is used. For regular requests, the page level template is used If there is a function called handler defined, that is the default handler function for all API\u0026rsquo;s For non-HTMX update requests (POST/PUT/DELETE), the Post-Redirect-Get pattern is automatically implemented by redirecting to the location pointed to by the Referer header. ","date":null,"permalink":"/docs/app/routing/","section":"Docs","summary":"Defining API routes, handling pages and fragments","title":"Request Routing"},{"content":"Clace applications run in a sandbox environment with no direct access to the system or Clace service. All access is through plugins. When an application is installed, the admin can audit the application for what access is being requested. Only the permissions which are approved are allowed at runtime.\nSecurity Model # The security model used by Clace is:\nThe application code, in Starlark(python) and HTML templates, is untrusted The Clace service and plugin code (in Go) are trusted The admin can audit and approve the access required by the untrusted application code when the app is being installed After installation, further application code updates do not require any further audit, as long as no new permissions are required. If the updated app code requires a new permission, the new plugin call will fail at runtime with a permission error. The trust boundary is about what the application can do in the backend. The frontend code is sandboxed by the browser, there is no additional auditing implemented for the frontend code.\nUsecases # This security model allows for the following:\nUsers can download applications and run on their machine, without worrying about what operations the app can do on their system outside the audited permissions Operations teams can install and approve applications. Further application updates can be handled by the development team, without requiring the operational admins to verify the updated code. As long as the application works within the originally defined permission boundary, application updates will continue to work Application developers can use LLM powered automated code generation tools without worrying about the side-effects of the code. If the generated code tries to perform any operation not previously approved, it will fail. Sample Application # As an example, the disk usage analysis app requires two permissions\napp = ace.app(\u0026#34;Disk Usage\u0026#34;, pages=[ace.page(\u0026#34;/\u0026#34;, block=\u0026#34;du_table_block\u0026#34;)], permissions=[ ace.permission(\u0026#34;exec.in\u0026#34;, \u0026#34;run\u0026#34;, [\u0026#34;du\u0026#34;]), ace.permission(\u0026#34;exec.in\u0026#34;, \u0026#34;run\u0026#34;, [\u0026#34;readlink\u0026#34;]) ], style=ace.style(\u0026#34;https://unpkg.com/mvp.css@1.14.0/mvp.css\u0026#34;), ) It requests permission to use the exec.in plugin to run two CLI commands, first being du and other being readlink. When installing the app\n$ ./clace app create /utils/disk_usage ./examples/disk_usage/ App audit results /utils/disk_usage : app2WPQHwr5ZpKELqh0TvP5YMSnbab Plugins : exec.in Permissions: exec.in.run [du] exec.in.run [readlink] App created. Permissions need to be approved an audit report is shown with these requests. To approve the requested permissions, the admin can do\n$ ./clace app audit --approve /utils/disk_usage App audit: /utils/disk_usage Plugins : exec.in Permissions: exec.in.run [du] exec.in.run [readlink] App permissions have been approved. The approval can be done during the app create itself, in that case the app is installed and approved immediately. None of the plugin code runs during the app creation, even for calls at the global scope. If the audit report does not match expectations, the app can be deleted.\n$ ./clace app create --approve /utils/disk_usage ./examples/disk_usage/ App audit results /utils/disk_usage : app2WPQpws6C1mWb6BujYGOdWMnF1C Plugins : exec.in Permissions: exec.in.run [du] exec.in.run [readlink] App created. Permissions have been approved $ ./clace app delete /utils/disk_usage App deleted /utils/disk_usage Once the app is created, if the application code is updated to change this line from\nret = exec.run(\u0026#34;readlink\u0026#34;, [\u0026#34;-f\u0026#34;, current], process_partial=True) to\nret = exec.run(\u0026#34;rm\u0026#34;, [\u0026#34;-f\u0026#34;, current], process_partial=True) The app will fail at runtime with an error like\napp /utils/disk_usage is not permitted to call exec.in.run with argument 0 having value \u0026#34;rm\u0026#34;, expected \u0026#34;readlink\u0026#34;. Update the app or audit and approve permissions The app cannot be run until either the code change is reverted or the admin approves the new call to rm.\nRoadmap # The following enhancements are planned for the security model\nSecrets management is planned, in such a manner that the application can request access to specific secrets. The application can use the secret but will not have direct access to the secret value, it will work with a reference to the secret key. ","date":null,"permalink":"/docs/applications/appsecurity/","section":"Docs","summary":"Application Security and sandboxing model for Clace","title":"Application Security"},{"content":"Most configuration options specified in the following sections are for the Clace server. The Clace client CLI, which talks with the Clace server using unix domain sockets, uses a small subset of the config properties. If the Clace client runs on the same machine as the server, then the same config file can be used for both. See here for details.\n","date":null,"permalink":"/docs/configuration/","section":"Docs","summary":"Configuration options for the Clace server and client.","title":"Configuration"},{"content":"","date":null,"permalink":"/docs/applications/","section":"Docs","summary":"Application routing and security details","title":"Managing Applications"},{"content":"HTTP # For HTTP requests, by default the Clace service listens on port 25222, on the localhost(127.0.0.1) interface. This means the HTTP port can be accessed from the same machine, it cannot be accessed remotely. To configure this, update the config file\n[http] host = \u0026#34;127.0.0.1\u0026#34; # bind to localhost by default for HTTP port = 25222 # default port for HTTP to desired values. Port 0 means bind to any available port. Port -1 means disable HTTP access. Use host as 0.0.0.0 to bind to all available interfaces.\nHTTPS # For HTTPS requests, the Clace service listens on port 25223 by default, on the any(0.0.0.0) interface. This means the HTTPS port can be accessed from the same machine and also remotely. The various HTTPS config settings are:\n# HTTPS port binding related Config [https] host = \u0026#34;0.0.0.0\u0026#34; # bind to all interfaces (if port is \u0026gt;= 0) port = 25223 # port for HTTPS enable_cert_lookup = true # enable looking for certificate files on disk before using Let\u0026#39;s Encrypt service_email = \u0026#34;\u0026#34; # email address for registering with Let\u0026#39;s Encrypt. Set a value to enable automatic certs use_staging = true # use Let\u0026#39;s Encrypt staging server cert_location = \u0026#34;$CL_HOME/config/certificates\u0026#34; # where to look for existing certificate files storage_location = \u0026#34;$CL_HOME/run/certmagic\u0026#34; # where to cache dynamically created certificates Port 0 means bind to any available port. Port -1 means disable HTTPS access.\nTLS Certificates # The default configuration is:\nDuring the first HTTPS request, $CL_HOME/config/certificates is looked up for a crt and key file in the PEM format matching the domain name as passed to the server. If a matching certificate is found, that is used. If no domain specific certificate is found, then the default certificate default.crt and default.key are looked up. If found, that is used. If default certificate is not found, and Lets Encrypt based certificate creation is disabled (the default), then a self-signed certificate is auto created in the certificates folder. The intent is to allow custom certificates to be placed in the certificate folder, which will be used. If not found, a self-signed certificate is created and used. For example, if a file example.crt and example.key are found in te certificates folder, those are used for example.com domain.\nEnable Automatic Signed Certificate # Clace uses the certmagic library for fully-managed TLS certificate issuance and renewal. Certmagic is disabled by default. To enable, the pre-requisites are:\nThe https config is using 443 as the port number. Running on privileged ports requires additional setup There is an DNS entry created pointing your host name or domain wildcard to the IP address of the host running the Clace server. This has to be done in your DNS provider config. Port 443 is reachable from the public internet. This has to be done in your infrastructure provider network settings. Once the pre-requisites are met, set the service_email config parameter to your email address. This enables certmagic based certificate creation. The config will look like:\n# HTTPS port binding related Config [https] host = \u0026#34;0.0.0.0\u0026#34; port = 443 enable_cert_lookup = true service_email = \u0026#34;MY_EMAIL@example.com\u0026#34; # CHANGE to your email address use_staging = true # CHANGE to false for production cert_location = \u0026#34;$CL_HOME/config/certificates\u0026#34; storage_location = \u0026#34;$CL_HOME/run/certmagic\u0026#34; Test out the certificate creation. If the certificate is getting created, change use_staging to false. Let\u0026rsquo;s Encrypt has strict rate limits, use the staging config to ensure that the pre-requisites are met before using the production config.\nWith this config, the certificates folder is looked up for any custom certificates for the domain. If not found, certmagic is used to create the certificate. Change enable_cert_lookup to false to disable local certificate lookup. If enable_cert_lookup is false, and service_email also is unset (certmagic is disabled), then the default.crt certificate is used for all requests.\nPrivileged Ports # On Linux, binding to low ports is disabled for non-root users. To enable binding to port 80 for HTTP and 443 for HTTPS, run the command\nsudo setcap cap_net_bind_service=+ep /path/to/clace_binary This would be required after any new build or update of the Clace binary.\nNotes # Please provide a valid email address in service_email. This allows you to receive expiration emails and also allows the CA to contact you if required. Start the configuration with staging use_staging = true, change to production config use_staging = false after ensuring that DNS and networking is working fine. If port 0 is used, the service will bind to any available port. Look at the stdout or logs to find the port used. Clients would have to be updated after every server restarted to point to the new port. Only the TLS-ALPN challenge is enabled in Clace. The HTTP and DNS based challenges are not supported currently. If Clace is running behind a load balancer, ensure that the load balancer is doing TLS pass-through. If TLS termination is done in the load balancer, then the automatic certificate management done by Clace through certmagic will not work. ","date":null,"permalink":"/docs/configuration/networking/","section":"Docs","summary":"Clace uses unix domain sockets for client CLI requests. HTTP and HTTPS are used for application requests. Automatic signed certificate creation is supported for HTTPS.","title":"Ports and Certificates"},{"content":"Request Structure # The handler function is passed one argument which has the details about the API call. The fields in this structure are:\nProperty Type Notes AppName string The app name in the config AppPath string The path where the app is installed. If root, then empty string AppUrl string The url for the app root PagePath string The path for the current page. If root, then empty string PageUrl string The url for the current page Method string The HTTP method, GET/POST etc IsDev bool Is the app installed in dev mode IsPartial bool Is this an HTMX driven partial request RemoteIP string The Client IP address UrlParams dict The url parameters, if used in the url spec Form dict The form data, including body and query Query dict The url query data, as a string array PostForm dict The form data from the body Data dict The response from the handler function Accessing Inputs # Url Parameters # For a route defined like\nace.page(\u0026#34;/user/{user_id}/settings\u0026#34;, \u0026#34;index.go.html\u0026#34;) the url parameter user_id can be accessed in the handler\ndef handler(req) user_id = req.UrlParams[\u0026#34;user_id\u0026#34;] Wildcard parameters are allowed at the end of the route. These are defined as\nace.page(\u0026#34;/path/*\u0026#34;, \u0026#34;index.go.html\u0026#34;) and can be accessed as\ndef handler(req) user_id = req.UrlParams[\u0026#34;*\u0026#34;] Regexes are also allowed in the path, these are defined as ace.page(\u0026quot;/articles/{aid:^[0-9]{5,6}}\u0026quot;) and accessed as req.UrlParams[\u0026quot;{aid}\u0026quot;]. The route will match only if the regex matches.\nQuery String Parameters # Query string parameters can be accessed as\ndef handler(req) name = req.Query.get(\u0026#34;name\u0026#34;) name = name[0] if name else None The value for Query is an string array, since there can be multiple query parameters with the same name.\nForm Data # Form data can be accessed like\ndef handler(req) name = req.Form.get(\u0026#34;name\u0026#34;) name = name[0] if name else None The value for Form is an string array, since there can be multiple form parameters with the same name.\n","date":null,"permalink":"/docs/app/request/","section":"Docs","summary":"The Request structure passed into the handler function, handling argument and post data","title":"Request"},{"content":"The default configuration for the Clace server is:\nApplication management (admin APIs) are accessible locally only, using unix domain sockets An admin user account is used to access applications The admin user password has to be added to the server config file, or a random password is generated every time the server is restarted Applications can be change not require any authentication There is no user management support in Clace currently, the plan is to integrate with OAuth2 providers and SAML services for managing user access Admin Account Password # When the Clace server is started, it looks for the entry\n[security] admin_password_bcrypt = \u0026#34;\u0026#34; # the password bcrypt value in the config file. If the value is undefined or empty, then a random password is generated and is used as the admin password for that server session. The password being used is displayed on the stdout of the server startup. This will change on every restart.\nTo configure a fixed value for the admin user password, use the helper command\nclace password To generate a random password. This will print out the password and its bcrypt value to the screen. Save the password in your password manager and add the bcrypt has to your config file.\nTo use a particular value for the admin password, run\nclace password --prompt This will prompt for the password and print out the bcrypt hash to add to the config file.\nAdmin API Access # By default, the Clace client uses Unix domain sockets to connect to the Clace server. Admin API calls to manage applications are disabled over HTTP/HTTPS by default. Unix sockets work when the client is on the same machine as the server, the client does not need to pass any credentials to connect over unix sockets. See here for details about the client configuration.\nTo enable remote API calls, where the client is on a different machine from the server, the server needs to be changed to add the following:\n[security] admin_over_tcp = true If running the Clace client from a remote machine, the config options required for the client are:\nserver_uri = \u0026#34;https://\u0026lt;SERVER_HOST\u0026gt;:25223\u0026#34; admin_user = \u0026#34;admin\u0026#34; [client] admin_password = \u0026#34;\u0026#34; # Change to actual password skip_cert_check = false # Change to true if using self-signed certs These can be specified in a client config file or can be set in the CLI command line. All other config entries are ignored by the Clace client. Note that to connect to a Clace server over HTTP remotely, the server needs to be bound to the all interface(0.0.0.0), see here.\nIf server_uri is set to the https endpoint and the Clace server is running with a self-signed certificate, set skip_cert_check = true in config or pass --skip_cert_check=true in client commands to disable the TLS certificate check.\nApplication Security # See appsecurity for details about the application level sandboxing.\n","date":null,"permalink":"/docs/configuration/security/","section":"Docs","summary":"Clace Security related configuration","title":"Security"},{"content":"Response Data # The Response from the handler function is passed to the template to be converted to HTML. The handler response is accessible through .Data, or $Data if in another scope. Any python object can be used as the return value. Using a dictionary is recommended, so that error handling is easier. Adding a Error key in the response dict can indicate to the template that an error condition needs to be handled.\nFor example, a handler like\ndef handler(req): name = req.Query.get(\u0026#34;name\u0026#34;) if name: return {\u0026#34;Name\u0026#34;: name[0], \u0026#34;Error\u0026#34;: None} else: return {\u0026#34;Error\u0026#34;: \u0026#34;Name not specified\u0026#34;, \u0026#34;Name\u0026#34;: None} app = ace.app(\u0026#34;test\u0026#34;, pages = [ace.page(\u0026#34;/\u0026#34;)]) allows the template to handle the error by doing\n{{block \u0026#34;clace_body\u0026#34; .}} {{if .Data.Error}} \u0026lt;div style=\u0026#34;color: red\u0026#34;\u0026gt;{{.Data.Error}}\u0026lt;/div\u0026gt; {{else}} Hi {{.Data.Name}} {{end}} {{end}} Redirect Response # If the API needs to redirect the client to another location after a POST/PUT/DELETE operation, the handler function can return an ace.Redirect structure. The fields in this structure are:\nProperty Optional Type Default Notes url false string The url to redirect to code true int 303 The HTTP status code, 303 or 302 For example, this code does a 303 redirect after a POST API, which provides proper handing for update requests.\ndef create_game(req): level = req.Form[\u0026#34;level\u0026#34;] ret = http.post(SERVICE_URL + \u0026#34;/api/create_game/\u0026#34; + level[0]) return ace.redirect(req.AppPath + \u0026#34;/game/\u0026#34; + ret.json()[\u0026#34;GameId\u0026#34;]) Custom Response # In some cases, a custom response need to be generated, with special headers. Or the response needs to use a template different from the one defined in the route, which could happen in the case of an error. For such cases, a ace.Response structure can be returned by the handler. The fields in this structure are:\nProperty Optional Type Default Notes data false object The response data block true string Optional only if type is \u0026ldquo;json\u0026rdquo; type true string inherited from the route type definition If \u0026ldquo;json\u0026rdquo;, block is ignored code true int 200 HTTP status code retarget true string HX-Retarget header value, CSS selector to target, like \u0026ldquo;#error_id\u0026rdquo; reswap true string HX-Reswap, like \u0026ldquo;outerHTML\u0026rdquo; For example, this handler code uses retarget to handle errors by updating the html property which has id \u0026ldquo;gameErrorId\u0026rdquo;\nret = http.post(api_url).json() if ret.get(\u0026#34;Error\u0026#34;): return ace.response(ret, \u0026#34;game_error_block\u0026#34;, retarget=\u0026#34;#gameErrorId\u0026#34;) return fetch_game(req, game_id) This code returns a 404 with a custom body generated from a template block called \u0026ldquo;invalid_challenge_block\u0026rdquo;\nif challenge.get(\u0026#34;Error\u0026#34;): return ace.response(challenge, \u0026#34;invalid_challenge_block\u0026#34;, code=404) JSON Response # All responses are HTML by default, as required for building a proper Hypermedia client. There are some cases where data needs to be returned to the client in JSON format. The type property can be used for those cases. For example, this API returns JSON\nace.page(\u0026#34;/memory\u0026#34;, handler=memory_handler, type=\u0026#34;json\u0026#34;), Here, the response from the handler function is returned as JSON, no template is used. Also, in this handler, if there is a call to ace.Response, the type will default to \u0026ldquo;json\u0026rdquo; since that is the type specified at the route level. Mime type detection based on the Accept header is planned, it is not currently supported.\n","date":null,"permalink":"/docs/app/response/","section":"Docs","summary":"The response from the handler function, custom response and redirects","title":"Response"},{"content":"","date":null,"permalink":"/docs/app/","section":"Docs","summary":"Developing Clace applications, managing API routes and HTML templates","title":"Developing Applications"},{"content":"Clace uses Go HTML templates for returning data to the client. See here for an overview of the template syntax.\nThe Sprig template library functions are included automatically. Two functions from Sprig which are excluded for security considerations are env and expandenv.\nTwo extra functions are added for handling static file paths.\nstatic function # This function takes a file name and returns the url for a file in the static folder with a sha256 hash included in the file name. This approach is based on the hashfs library. If the static folder contains a file file1 with the content file1data, then a call to static \u0026quot;file\u0026quot; will return /test/static/file1-ca9e40772ef9119c13100a8258bc38a665a0a1976bf81c96e69a353b6605f5a7, assuming the app is installed at /test.\nThe returned file name has a hash based on the file contents. The file server used by Clace serves will serve aggressive cache headers Cache-Control: public, max-age=31536000 when this file is referenced by the browser. When the file contents change, the hash will change and the file name will change. The files on disk are not renamed, only the filesystem used by the Clace server in memory sees the hashed file names.\nThis approach allows for a build-less system with the aggressive static asset caching. The usual approach for this requires the static file to be renamed to have the hash value in the file name on disk. This require a build step to do the file renaming. The hashfs approach can avoid the build step while having the additional overhead that the file hash has to be generated once every time a new static file is referenced from a server session. Since the file is cached on the browser after first access, this overhead is not significant. The advantages in term of simplifying the deployment process by avoiding the need for a build step are much higher.\nfileNonEmpty function # The fileNonEmpty function returns a bool, indicating whether a static file with that non-hashed name is present and is not empty. This can be used to conditionally include style files if present.\nFor example\n{{ if fileNonEmpty \u0026#34;css/style.css\u0026#34; }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ static \u0026#34;css/style.css\u0026#34; }}\u0026#34; /\u0026gt; {{ end }} checks if the \u0026ldquo;css/style.css\u0026rdquo; file is present and not empty. If so, it is linked using the static function, which returns a hashed file name which can be cached aggressively.\nNote: The path passed to static and fileNonEmpty functions should not include static, it is automatically added. So use {{ static \u0026quot;css/style.css\u0026quot; }}, not {{ static \u0026quot;static/css/style.css\u0026quot; }} Template File Location # Templates are loaded once on app initialization. In dev mode, they are automatically reload on file updates. By default, the app source home directory is searched for template files. This can be changed by adding this directive in the ace.app config.\nsettings={ \u0026#34;routing\u0026#34;: {\u0026#34;template_locations\u0026#34;: [\u0026#34;*.go.html\u0026#34;, \u0026#34;templates/*.go.html\u0026#34;]} } the default is [\u0026quot;*.go.html\u0026quot;]. If additional directories are added, \u0026quot;*.go.html\u0026quot; still needs to present in the list since generated files are created in the app home directory. Also, all folders in the list need to contains at least one template file. File names have to be unique across folders. Files are referenced by their name, without the folder name, when used in template import directives.\n","date":null,"permalink":"/docs/app/templates/","section":"Docs","summary":"HTML templates functions, static file handling and customizations","title":"Templates"},{"content":"Goals # The goals Clace is being built to support are:\nEnable development and deployment of secure internal web applications. Simplify ongoing maintenance of such apps by removing build and dependency related issues. Enable uses cases where developing custom web applications would have been too cumbersome before Clace. App Development Features # The dev time features supported currently by Clace are:\nHypermedia driven backend API design, simplifying UI development. Dynamic reload using SSE (Server Sent Events) for all application changes, backend and frontend. Automatic creation of ECMAScript modules using esbuild. Automatic download for JavaScript and CSS dependencies. Support for TailwindCSS and DaisyUI watcher integration. Template caching and automatic reload on changes. App Deployment Features # The deployment features supported currently by Clace are:\nBackend app code run in a security sandbox, with allowlist based permissions. No build step, the development artifacts are ready for production use. Zero downtime application updates. Scalable backend, all performance critical code is in Go, only application handler code is in Starlark. Support for domain based and path based routing at the app level. Virtual filesystem with content hash based file names, enabling aggressive static content caching. Automatic SSL certificate creation based on certmagic. Roadmap # Clace is early in its development. The feature roadmap for Clace is:\nSupport for OAuth2 based login. Support for SSO with SAML. All plugins are internal (built into Clace binary) currently. The plan is to move to an external plugin model, plugins being loaded dynamically using go-plugin. Support for github integration, apps being deployed from artifacts directly loaded from github. SQLite is used as the metadata storage currently. Support for postgres and other systems is planned. Preview mode for app updates, to check whether changes work before making them live. Support for workflow jobs, which would have a form based interface with limited customizability, but with support for triggered and scheduled execution. Support for application data persistance. UI interface for Clace admin operations. Record replay based automatic integration test creation. Record all responses at the plugin boundary and use that to replay integration test scenarios. This is speculative currently, depending on the how the external plugin model is implemented. Distributed agent model, where the Clace server does the initial routing but the actual application execution happens on remote worker nodes. This feature, when added, might use a different licensing model. This is also speculative currently. ","date":null,"permalink":"/features/","section":"Clace","summary":"Features supported by Clace","title":"Features"},{"content":"What is Clace? # Clace is an open-source project (Apache-2.0 Licensed) building a secure platform to develop and deploy internal web applications. Clace provides a web application server focused on securely running multiple applications on a single installation. Applications are full stack, with a backend which can talk to external endpoints, the frontend can be auto generated forms or fully customizable web applications.\nProject Goals # The goal of this project is to make it easy for individuals and teams to develop and manage lightweight full stack applications in a secure manner. Fully configurable and secure internal web applications with minimal code is the goal. Easy integrations to enable SSO/SAML based authentication and authorization controls, audit logs and integration with secrets manager for managing credentials are goals.\nA single developer should be able to manage the full application lifecycle, frontend and backend development, test automation and production deployment. Deployments should support a gitops like approach, with automatic preview environment to verify changes before making them live.\nClace aims to give a dynamic development environment for applications with automatic reload of code changes, while providing a performant and scalable platform which is operationally simple to manage.\nTerminology # Internal applications: Web applications built or downloaded for use by an individual or teams. For users, this could be apps to manage their machine, like monitor disk usage across folders. For teams, apps could automate common operations like setting resource limits, provisioning accounts etc. Sandboxing: Sandboxing is a security mechanism to ensure that an application stays within the rules set by the admin. If an application is configured to perform GET requests, trying to do a POST request from the application will fail until the admin authorizes the application to perform POST requests. What\u0026rsquo;s with the name # The name Clace is a play on Command Line Ace, since an UI for command line applications is an initial target use-case. The name is pronounced like Place, with a C.\nWhy is there a need for such a platform? # There are tools like Rundeck and Jenkins which allow automating operational scripts. These have very limited UI customizability. At the other extreme, SaaS services like Retool which focus on internal tools development allow developing a customizable UI using no-code generators. These speed up the initial development experience to some extent but at the cost of operational complexity. Ongoing maintenance and updates for such low-code applications does not work well with general software development lifecycle practices. Most such tools use a heavy-weight single page application (SPA) based UI model.\nClace aims for a middle ground, aiming for easy self-hosting and operational simplicity while allowing fully customizable lightweight hypermedia driven applications, with a focus on security.\nWhat will success look like? # For the Clace project, success will mean:\nUsers can easily develop web applications for common use-cases Users can download and install such applications from the internet, without security being a concern Applications can be securely shared across teams, with operational concerns like SSO, audit logs etc automatically handled How is Clace implemented? # The way Clace tries to achieve these goals are:\nSingle binary web application server (in golang), with a set of plugins built in (also in golang) which allow access to external endpoints. The server is statically configured using a TOML file. Applications are configured using Starlark, which is a subset of Python. Python is an ideal glue language, Starlark is used to configure the application backend logic Multiple applications can be dynamically installed, an embedded SQLite database is used to store application metadata (Postgres support is in the roadmap). Path based routing, each app identified by a unique path. Also, domain based routing, which allows multiple domains to point to the same Clace instance, with path based routing being done independently for each domain. Automatic TLS certificate management for each domain to simplify deployments. A sandboxing layer is implemented at the Starlark(python) to Golang boundary, allowing the implementation of security and access control policies. Go code is trusted, Starlark code is untrusted. The application UI is implemented using Go HTML templates, with HTMX for interactivity. Go templates support context aware templating which prevents encoding related security issues. They also work well with the HTML fragments required for HTMX. No need to install any additional components like Python or NodeJS/NPM. Integration with tailwindcss-cli and esbuild (using the esbuild go library) is planned, but there are no plans to implement support for the full Javascript build tool ecosystem. What applications are suited for Clace? # Clace aims to provide a set of plugins which allow for features like Sandboxing for security and auto generation of tests. The plugins are implemented in Go and are exposed to the application through a Starlark interface. The initial plugins which will be implemented are HTTP client, command line application (CLI) runner, Slack, Github etc. The availability of plugins will limit which kinds of applications are suited for Clace.\nApplications suited for Clace currently would include:\nExposing a UI for a command line application Exposing a UI for a existing REST service (backend for frontend model) What applications are NOT suited for Clace? # Applications not suited for Clace would include:\nApplications which need to implement a complex database model, those would be better handled with Django/Rails/Spring Boot like frameworks. Applications which require a SPA style UI. This page gives a good overview of when a Hypermedia style UI would be a good fit. Since the Javascript build tooling support will be limited in Clace, Clace is not a backend to use when the intent is to develop a React/Angular/Vue SPA frontend. Clace is intended as platform to use when the UI can be a Hypermedia based one. Current Status # The development of Clace was started in April 2023. As of Sept 2023, basic functionality for the Clace server is functional. The current status is:\nClient and server (in a single binary) for service management and configuration Initial support for application development with Starlark based configuration Go HTML template loading and caching for request processing HTTP plugin for communicating with REST endpoints exec plugin for running system commands Built in admin account for local development Auto-sync (file system watcher) and Auto-reload using SSE (automatic UI refresh) for speeding up the application development cycle Admin functionality using unix domain sockets for security Application sandboxing checks to ensure only audited operations are allowed The next steps are to polish the application development interface, add support for loading eternal plugins, add support for SSO and RBAC etc. The aim is to do a beta release by October 2023 and a 1.0 release after that.\nWho is behind this project? # The project was started by Ajay Kidave. Ajay\u0026rsquo;s background has been in database systems and enterprise integration tools. Clace is an independent project that Ajay started while continuing to work as a consultant.\nWhat is the longer-term plan for Clace? # The current plan is to develop the open source project, with the aim of making Clace a great platform for managing internal applications. The service can currently scale up vertically, support for metadata storage in Postgres will be added which will enable horizontal scaling also.\nFor workload isolation and security reasons, some use cases might require a more distributed backend approach. An worker/agent mode is planned in the longer-term. This will mean the Clace server will not actually run the application code, the application code will run on distributed agents. The agent mode, when added, might use a different licensing model. Most regular use-cases should not require the agent mode; vertical and horizontal scaling should cover normal workloads. The core functionality of Clace, including SSO integration and all plugins, will remain Apache-2.0 licensed.\n","date":null,"permalink":"/about/","section":"Clace","summary":"Information about the use-cases for which Clace was built","title":"About Clace"},{"content":"What is Clace Clace is an Apache-2.0 licensed open-source project building a secure platform to develop and deploy internal web applications. Clace provides a web application server focused on securely running multiple applications on a single installation. Clace apps are Hypermedia driven full stack web applications. Who is it for Clace can be used by individuals to host web applications for personal use. Clace can also be used by teams to securely share applications across teams. Using simple python like syntax to configure the backend and HTML with hypermedia extensions for frontend, users can develop and share interactive applications. There are no python or Javascript dependencies to worry about, application changes can be done with no build step required. How does it work Clace allows applications to be configured in Starlark (subset of Python syntax). The API routes are defined to be Hypermedia first, using HTML templates to drive the UI interactions. Templates are written using Go HTML templates. HTMX is used for server interactions. The backend code runs in a security sandbox, access to plugins has to be explicitly allowed. Examples See docs for documentation about creating basic apps. See github for sample application code. Secure platform with application sandboxing\nHypermedia first UI approach\nApplications configured using Python(Starlark)\nSingle binary deployment for easy installation\nSign up for email updates Subscribe ","date":null,"permalink":"/","section":"Clace","summary":"What is Clace Clace is an Apache-2.","title":"Clace"},{"content":"Clace is an open-source project which aims to make it easy for individuals and teams to develop and manage lightweight full stack web applications in a secure manner.\n","date":null,"permalink":"/docs/","section":"Docs","summary":"Clace is an open-source project which aims to make it easy for individuals and teams to develop and manage lightweight full stack web applications in a secure manner.","title":"Docs"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]