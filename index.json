[{"content":"Clace applications implement a Hypermedia driven approach for developing web applications. Applications return HTML fragments as API response using Go html templates. The UI uses HTML enhanced with hypermedia controls using the HTMX library to implement user interactions.\nThe backend API routes and dependencies like CSS library, JavaScript modules etc are configured using Starlark configuration. Any custom API handling required is implemented in handler functions also written in Starlark. Starlark is a subset of python, optimized for application configuration usecases.\nStructure # The structure of a Clace application is:\nOne Clace application per folder, static sub-folder contain static assets An app.star Starlark file, defining the application configuration Predefined builtins, accessed through the ace namespace A global called app, created using app = ace.app() call An optional default handler function called handler. Other handlers are referenced in the route config An html template file called index.go.html if using custom layout If not using custom layout, an html template block called clace_body defined in any *.go.html file, for example app.go.html App Lifecycle # The Clace app development lifecycle is:\nCreate a folder for the app, with the app.star file and templates. Start the Clace server. Create an app using clace app create --dev. This runs the app in dev mode. In dev mode, some additional files are generated, with _gen in the file name. CSS dependencies and JavaScript modules are downloaded into the static folder. After the app development is done, the whole app folder can be checked into source control. There is no build step. Create a production app, clace app create, without the --dev. The app is now live. The Clace server can host multiple applications, each application has a dedicated path and optionally a dedicated domain. Examples # Simple App # The simplest app, using the default builtin layout would be two files. An app.star file containing\napp = ace.app(\u0026#34;hello1\u0026#34;, pages = [ace.page(\u0026#34;/\u0026#34;)]) and an app.go.html file containing\n{{block \u0026#34;clace_body\u0026#34; .}} Hello World {{end}} Create an app in dev mode with this code and visiting the app url will show Example Output The name of the app is hello1. There is only one route defined, for page /, which shows a HTML page with the name of the app. The body is generated from the contents of the app.go.html file. A more verbose way to write the same app config would be\napp = ace.app(name=\u0026#34;hello1\u0026#34;, custom_layout=False, pages = [ace.page(path=\u0026#34;/\u0026#34;, full=\u0026#34;index_gen.go.html\u0026#34;)] ) index_gen.go.html is the auto generated index file, created when the default builtin layout is used.\nApp with Custom Layout # To create an app with a custom HTML page which shows a listing of files in your root directory, create an app.star file with\nload(\u0026#34;exec.in\u0026#34;, \u0026#34;exec\u0026#34;) def handler(req): ret = exec.run(\u0026#34;ls\u0026#34;, [\u0026#34;-l\u0026#34;, \u0026#34;/\u0026#34;]) return {\u0026#34;Lines\u0026#34;: ret.lines} app = ace.app(\u0026#34;hello1\u0026#34;, custom_layout=True, pages = [ace.page(\u0026#34;/\u0026#34;)], permissions = [ace.permission(\u0026#34;exec.in\u0026#34;, \u0026#34;run\u0026#34;, [\u0026#34;ls\u0026#34;])] ) and an index.go.html file with\n\u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;File List\u0026lt;/title\u0026gt; {{ template \u0026#34;clace_gen_import\u0026#34; . }} \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {{ range .Data.Lines }} {{.}} \u0026lt;br/\u0026gt; {{end}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; This app uses the exec plugin to run a ls command. The output of the command is shown when the app is accessed. To allow the app to run the plugin command, use the clace app approve command.\nMore examples # There are more examples here. The disk_usage example uses the MVP classless library for styling and shows a basic hypermedia flow. The cowbull game examples has multiple pages, each page with some dynamic behavior. Clace does not currently have a persistence layer. The cowbull game depends on another service for data persistence, so it is implementing a backend for frontend pattern. For styling, it uses the DaisyUI component library for Tailwind CSS. These two examples work fine with Javascript disabled in the browser, falling back to basic HTML without any HTMX extensions.\nThe memory_usage example uses the d3 library to show a interactive display of the memory usage for processes on the machine. The plot library is automatically imported as a ECMAScript module and the custom javascript code works with a JSON api on the backend. The default in Clace is hypermedia exchange, JSON can be used for data API\u0026rsquo;s.\nThese examples are live on the demo page.\n","date":null,"permalink":"/docs/app/overview/","section":"Docs","summary":"Overview of the Clace application development model","title":"Overview"},{"content":"Request Routing # The Clace server can host multiple applications simultaneously. Each application gets a dedicated path, the application can use all sub-paths within that without conflicts with other applications.\nWhen an application is created, a path needs to be specified and a domain can be optionally specified. Routing for application requests is done based on domain and path. The domain is the namespace within which the paths are resolved.\nConsider this scenario:\nApp A is installed at /utils/appA App B is installed at /appB App C is installed at the root level / for domain example.com, example.com:/ App D is installed at /test for test.mydomain.com, test.mydomain.com:/test App E is installed at /test2 for test.mydomain.com, test.mydomain.com:/test2 For every API call, the Clace server first checks whether the API call is against a domain namespace which is currently configured in Clace. If so, applications matching that domain are looked up. If no matching domain is located, then the default namespace (with no domain) is looked up.\nFor the above scenario:\nRequests to /utils/appA/* for any domain other than example.com and test.mydomain.com will go to App A. Requests to /appB/* for any domain other than example.com and test.mydomain.com will go to App B. Requests to example.com for any path will always go to App C, since it is installed at the root path. Requests to test.mydomain.com:/test/* will go to App D. Requests to test.mydomain.com:/test2/* will go to App E. Requests to test.mydomain.com for any path other than /test or /test2 will fail with a 404. Creating Applications # When an app is being created, a path and an optional domain need to be specified. For the above example scenario:\nNo new apps can be created for example.com domain, since App C is installed at the root path. For the test.mydomain.con domain, no new app can be created under /test and /test2, other paths are available. For the default domain, /utils/appA and /appB are taken, other paths are available. New apps can be created under any path, including root path, for new domains and subdomains, like test.example.com. Notes # The domain specified for the app is used only for routing requests. The user has to ensure that the actual DNS routing is done properly outside of Clace for the API calls to land on the Clace server. Using wildcard DNS entries will reduce the configuration required in the DNS service. So if *.example.com points to the IP address of the Clace service, any domain based routing done in Clace will work with no further DNS configuration being required. The automated certificates created by Clace will be domain level certificates, wildcard certificates are not currently created. /_clace/ API path at the root level and /_clace_app/ within an app path are reserved paths, they are used by the Clace internal APIs, requests will not reach the app. This applies for all domains. _cl_ is reserved for use for internal apps, so app path last component cannot have _cl_. ","date":null,"permalink":"/docs/applications/routing/","section":"Docs","summary":"Installing apps and managing request routing across Clace applications, using path and domain","title":"Application Routing"},{"content":"Install Release Build # To install the latest release build, run the install script. Note down the password printed. Add the env variables as prompted and then start the service.\ncurl -L https://clace.io/install.sh | sh source $HOME/clhome/bin/clace.env clace server start \u0026amp; clace app create --approve /disk_usage github.com/claceio/clace/examples/disk_usage/ The app should be available at https://127.0.0.1:25223/disk_usage after allowing the self-signed certificate. admin is the username and use the password printed by the install script. See start the service for details.\nInstall from Source # To install from source\nEnsure that a recent version of Go is available, version 1.21.0 or newer. Checkout the Clace repo. The below instructions assume you are using $HOME/clhome/clace.toml as the config file and $HOME/clhome as the work directory location. First add the below env variables to your shell .profile or .bash_profile:\nexport CL_HOME=$HOME/clhome export CL_CONFIG_FILE=$CL_HOME/clace.toml export PATH=$CL_HOME/bin/:$PATH Source the update profile file, like source ~/.bash_profile. Build the Clace binary\n# Ensure go is in the $PATH mkdir -p $CL_HOME/bin mkdir $HOME/clace_source \u0026amp;\u0026amp; cd $HOME/clace_source git clone -b main https://github.com/claceio/clace \u0026amp;\u0026amp; cd clace go build -o $CL_HOME/bin/clace ./cmd/clace/ Initial Configuration # To use the clace service, you need an initial config file with the service password and a work directory. Create the clace.toml file, and create a randomly generate password for the admin user account\nclace password \u0026gt; $CL_HOME/clace.toml This will print a random password on the screen, note that down as the password to use for accessing the applications.\nStart the service # To start the Clace server, run\nclace server start The service logs will be going to $CL_HOME/logs. To get the logs on the console also, you can add -c -l DEBUG to the server start command. The service will be started on https://localhost:25223 by default.\nLoad an App # To create an app, run the Clace client\nclace app create --dev /disk_usage $HOME/clace_source/clace/examples/disk_usage/ To audit and approve the app\u0026rsquo;s security policies, run\nclace app approve /disk_usage This will create an app at /disk_usage with the example disk_usage app. The disk_usage app provides a web interface for the du command, allowing the user to explore the subfolders which are consuming most disk space.\nTo access the app, go to https://127.0.0.1:25223/disk_usage. Use admin as the username and use the password previously generated. Allow the browser to connect to the self-signed certificate page. Or connect to http://127.0.0.1:25222/disk_usage to avoid the certificate related warning.\nThe code for the disk usage app is in GitHub. app.star is the starlark config and app.go.html is the html template. The other files are generated files and are created by Clace during app development.\n","date":null,"permalink":"/docs/installation/","section":"Docs","summary":"How to install Clace and do initial setup","title":"Installation"},{"content":"Clace Server # The Clace server picks up its configuration from the config file specified at startup.\n$ clace server start -h NAME: clace server start - Start the clace server USAGE: clace server start [command options] [arguments...] OPTIONS: --server-uri value, -s value The server connection uri (default: \u0026#34;$CL_HOME/run/clace.sock\u0026#34;) [$CL_SERVER_URI] --admin-user value, -u value The admin user name (default: \u0026#34;admin\u0026#34;) [$CL_ADMIN_USER] --http.host value, -i value The interface to bind on for HTTP (default: \u0026#34;127.0.0.1\u0026#34;) [$CL_HTTP_HOST] --http.port value, -p value The port to listen on for HTTP (default: 25222) [$CL_HTTP_PORT] --https.host value The interface to bind on for HTTPS (default: \u0026#34;0.0.0.0\u0026#34;) [$CL_HTTPS_HOST] --https.port value The port to listen on for HTTPS (default: 25223) [$CL_HTTPS_PORT] --logging.level value, -l value The logging level to use (default: \u0026#34;INFO\u0026#34;) [$CL_LOGGING_LEVEL] --logging.console, -c Enable console logging (default: false) [$CL_LOGGING_CONSOLE] --help, -h show help GLOBAL OPTIONS: --config-file value, -c value TOML configuration file [$CL_CONFIG_FILE] --help, -h show help All the parameters have default values, specified in the code at clace.default.toml.\nA user-specified config file is required. The location of this file can be set using the command line arg --config_file. If CLI arg is not specified, the environment variable CL_CONFIG_FILE is used to locate the config file. There is no default location for this file, if no CLI argument and env value are specified, then no configuration file is loaded.\nAll arguments are read from the user specified configuration file. Some arguments are further configurable in the CLI or env. For example, set --http.host=7777 or env CL_HTTP_PORT to set the http port. The precedence order, from highest priority to lowest is:\nCLI argument ENV variable User specified config Default config in the source code for the Clace build version Home Directory # The CL_HOME environment variable is used to locate the home directory for the Clace server. If no value is set, this defaults to the directory from which the Clace server was started. This location is used to store:\nThe sqlite database containing the metadata information, default is $CL_HOME/clace.db The logs for the service, under the logs folder. The config folder contains the certificates to be use for TLS. The run folder contains app specific temporary files. Clace Client CLI # By default, the Clace client uses Unix domain sockets to connect to the Clace server. The $CL_HOME should point to the same location for server and client. If no changes are done for the server defaults, then the client can connect to the server locally without any other configuration being required. See here for details about the client configuration.\n","date":null,"permalink":"/docs/configuration/overview/","section":"Docs","summary":"Overview of Clace configuration, at the server level and client level and the $CL_HOME location for files","title":"Overview"},{"content":"Application Types # A Clace application can be one of four types:\nDevelopment Apps : Used for developing apps, supports live reload from code change on disk. Production Apps : For production use. Can be created from git hosted source or from sources on local disk. Staging Apps : For reviewing code and config changes before they are pushed to prod. Every prod app has one staging app. Preview Apps : For creating a review environment for code changes, useful as part of code review. Development Apps # Development mode apps are used for developing or updating Clace apps. The source for these apps has to be on local disk, it cannot be git. Any code or config changes are live reloaded immediately for dev apps. To create a dev mode app, add the --dev option to the app create command. For example,\nclace app create --dev --approve /myapp /home/user/mycode Production Apps # Without the --dev options, apps are created as production apps by default. Production apps can be created from source on GitHub or from local disk. In either case, the source code for the app is uploaded to the Clace metadata database. For example:\nclace app create --approve example.com:/ /home/user/mycode creates an production app. After app creation, the original source location is not read, until a app reload operation is done to update the sources. The source folder /home/user/mycode can be deleted if reload is not required, since the sources are present in the Clace metadata database. Every production app automatically has one staging app associated with it.\nStaging Apps # Staging apps are created for each production app. The purpose of staging app is to be able to verify config and code changes before they are made live in the prod app. For example, after the previous app create command, a call to app list with the --internal option will show two apps:\nclace app list --internal Id Type Version GitCommit GitBranch Domain:Path SourceUrl app_prd_2aMvX3fc9fH18n6i2Jew0tNxnky PROD 1 example.com:/ /home/user/mycode app_stg_2aMvX3fc9fH18n6i2Jew0tNxnky STG 1 example.com:/_cl_stage /home/user/mycode The second app is the staging app for the first. app list shows only the main apps by default, the --internal option makes it show the linked apps.\nThe staging app url is available by suffixing _cl_stage at the end of the app path. So for an app at https://example.com/, the staging url is https://example.com/cl_stage. For an app at https://example.com/utils/app1, the staging app url is https://example.com/utils/app1_cl_stage.\nPromoting Changes # When there are code changes, running app reload will update the staging environment.\nclace app reload example.com:/ Reloaded apps: example.com:/_cl_stage 1 app(s) reloaded, 0 app(s) approved, 0 app(s) promoted. The staging app is version 2 now, prod app is still at version 1.\nclace app list -i Id Type Version GitCommit GitBranch Domain:Path SourceUrl app_prd_2aMvX3fc9fH18n6i2Jew0tNxnky PROD 1 example.com:/ /home/user/mycode app_stg_2aMvX3fc9fH18n6i2Jew0tNxnky STG 2 example.com:/_cl_stage /home/user/mycode At this point, going to the url example.com:/_cl_stage will show the updated code while example.com:/ has not been updated. To promote the changes to prod, run app promote\nclace app promote example.com:/ Promoting example.com:/ 1 app(s) promoted. The prod app is at the same version as the staging app now\nclace app list -i Id Type Version GitCommit GitBranch Domain:Path SourceUrl app_prd_2aMvX3fc9fH18n6i2Jew0tNxnky PROD 2 example.com:/ /home/user/mycode app_stg_2aMvX3fc9fH18n6i2Jew0tNxnky STG 2 example.com:/_cl_stage /home/user/mycode If the application code change requires new permissions, the reload operation will fail unless --approve is added.\nTo do the reload, approval and promotion is one step, do clace app reload --approve --promote example.com:/.\nGitHub Reload # The rules for fetching source code from local disk and GitHub are:\nIf the source url starts with http://, https:// or github.com, the source is assumed to be from a github API endpoint. Otherwise the source is assumed to be local disk on the Clace server. If Clace client and server are on different machines and local disk is being used, the code needs to be copied to the server node first. For GitHub source, the format is https://domain_name/org_name/repo_name/sub/folder, like github.com/claceio/clace/examples/disk_usage. The sub_folder should contain the app.star config file. During app create and app reload, the commit id takes precedence over the branch name if both are specified. During app reload, if no branch and commit are specified, the newest code is checked out from the current branch. main is used as current branch if no branch was previously specified for the app. Glob Pattern # The app reload/promote/approve/list commands accept a glob pattern. example.com:** will match apps under the example.com domain. *:** will match all apps in all domains, all is a shortcut for this. When using glob patterns, place the pattern inside double-quotes to avoid issues with shell star expansion. For example, \u0026quot;example.com:**\u0026quot;\nThe default for list command is to list all apps. All other command require an glob pattern to be specified explicitly.\nWhen multiple apps are being updated, if any one app fails, the whole operation is rolled back. This allows for atomic updates across multiple applications.\nUse the --dry-run option with any write CLI call to verify if the options specified are correct before the actual run. No changes are committed during dry-run.\nPreview Apps # Preview allows the creation of any number of linked preview apps for a main app. This is supported for apps created from GitHub source. The commit id to use needs to be specified when creating the preview. For example,\nclace preview create /myapp 49182d4ca1cacbd8e3463a77c2174a6da1fb66c9 creates an app accessible at /myapp_cl_preview_49182d4ca1cacbd8e3463a77c2174a6da1fb66c9 which runs the app code in the specified commit id.\nPreview apps cannot be changed once they are created. If preview app requires new permissions, add the --approve option to the preview create command.\nWrite Mode Access # Staging and Preview apps have read only access by default to plugin APIs. This means that when they make calls to plugin APIs, only APIs defined as READ by the plugin are permitted. The HTTP plugin defines GET/OPTIONS/HEAD requests as READ type, POST/PUT/DELETE are defined as WRITE. For the CLI Exec plugin, the run API is defined as WRITE since the CLI command run might do write operations.\nFor cases where the plugin defines an API as Write, the app permission can overwrite the default type and define the operation to be a READ operation. For example, the disk_usage app runs the du command, which is a read operation. The app config defines the run plugin call as type=\u0026quot;READ\u0026quot;, over-riding the default WRITE type defined in the plugin. If no type is specified in the permission, the type defined in the plugin takes effect.\nStaging and Preview apps are allowed only READ calls by default, even if the app permissions allow WRITE operations. To allow stage apps access to WRITE operations, run clace app update stage-write-access all true. Change all to the desired app glob pattern.\nTo allow preview apps access to WRITE operation, run clace app update preview-write-access example.com:/ true. This changes the existing preview apps and any new preview apps created for example.com:/ to allow write operations, if the permissions have been approved.\n","date":null,"permalink":"/docs/applications/lifecycle/","section":"Docs","summary":"Lifecycle for Clace applications, pushing changes live safely","title":"Application Lifecycle"},{"content":"The request routing layer in Clace is built on top of the chi routing library. The routing is built for hypermedia exchange, so all routes are defined in terms of pages and fragments within the pages. This grouping of requests helps make it clear which API does what and provide an easy mechanism to deal with partial HTMX driven requests and full page refreshes. Simpler application might have one page with some interactions within that. Larger applications can be composed of multiple pages, each page having some interactive fragments.\nPages # The app contains an pages array, which defines all the routes for the app. For example, the app definition\napp = ace.app(\u0026#34;hello1\u0026#34;, pages = [ ace.page(\u0026#34;/\u0026#34;), ace.page(\u0026#34;/help\u0026#34;, \u0026#34;help.go.html\u0026#34;) ] ) defines two routes. / routes to the default index page, /help routes to the help page.\nPage # ace.Page is used to define the properties for a single page. The parameters for ace.page are:\nProperty Optional Type Default Notes path False string The route, should start with a / full True string index.go.html if custom layout, else index_gen.go.html The template to use for full page requests partial True string None The template to use for partial page requests handler True function handler (if defined) The handler function to use for the route fragments True ace.fragment[] [] The fragment array method True string GET The HTTP method type: GET,POST,PUT,DELETE etc type True string html The response type, html or json Fragment # The fragments array in the page definition defines the API interactions within the page. The parameters for ace.Fragment are:\nProperty Optional Type Default Notes path False string The route, should not start with a / partial True string Inherited from page The template to use for partial requests handler True function Inherited from page The handler function to use for the route method True function GET The HTTP method type: GET,POST,PUT,DELETE etc type True string html The response type, html or json Note: partial and handler are inherited from the page level, unless overridden for the fragment. For example, in this page definition\nace.page(\u0026#34;/game/{game_id}\u0026#34;, full=\u0026#34;game.go.html\u0026#34;, partial=\u0026#34;game_info_tmpl\u0026#34;, handler=game_handler, fragments=[ ace.fragment( \u0026#34;submit\u0026#34;, method=\u0026#34;POST\u0026#34;, handler=lambda req: post_game_update(req, \u0026#34;submit\u0026#34;)), ace.fragment( \u0026#34;refresh\u0026#34;, partial=\u0026#34;refresh_tmpl\u0026#34;) ] ) there are three API\u0026rsquo;s defined:\nGET /game/{game_id} : game_handler is the handler function, full page request returns game.go.html, partial HTMX request returns game_info_tmpl template. POST /game/{game_id}/submit : The handler is a lambda function. The game_info_tmpl template partial is inherited from the page as the response for the POST. GET /game/{game_id}/refresh : game_handler is inherited from the page. For full page, it returns the game.go.html response. For partial HTMX requests, refresh_tmpl template is returned. API Flow # The API flow is\nThe API is first sent to the matching app Within the app, the API is routed based on the routes defined If there is a handler defined for the matched route, the handler function is called with the request as argument The response template is invoked, with a input map containing a Data property as returned by the handler function If the API type is set to json, the handler response is directly returned, with no template being used Notes # For HTMX requests, the partial template is used. For regular requests, the page level full template is used If there is a function called handler defined, that is the default handler function for all API\u0026rsquo;s For non-HTMX update requests (POST/PUT/DELETE), the Post-Redirect-Get pattern is automatically implemented by redirecting to the location pointed to by the Referer header. ","date":null,"permalink":"/docs/app/routing/","section":"Docs","summary":"Defining API routes, handling pages and fragments","title":"Request Routing"},{"content":"Most configuration options specified in the following sections are for the Clace server. The Clace client CLI, which talks with the Clace server using unix domain sockets, uses a small subset of the config properties. If the Clace client runs on the same machine as the server, then the same config file can be used for both. See here for details.\n","date":null,"permalink":"/docs/configuration/","section":"Docs","summary":"Configuration options for the Clace server and client.","title":"Configuration"},{"content":"","date":null,"permalink":"/docs/applications/","section":"Docs","summary":"Application routing and security details","title":"Managing Applications"},{"content":"HTTP # For HTTP requests, by default the Clace service listens on port 25222, on the localhost(127.0.0.1) interface. This means the HTTP port can be accessed from the same machine, it cannot be accessed remotely. To configure this, update the config file\n[http] host = \u0026#34;127.0.0.1\u0026#34; # bind to localhost by default for HTTP port = 25222 # default port for HTTP to desired values. Port 0 means bind to any available port. Port -1 means disable HTTP access. Use host as 0.0.0.0 to bind to all available interfaces.\nHTTPS # For HTTPS requests, the Clace service listens on port 25223 by default, on the any(0.0.0.0) interface. This means the HTTPS port can be accessed from the same machine and also remotely. The various HTTPS config settings are:\n# HTTPS port binding related Config [https] host = \u0026#34;0.0.0.0\u0026#34; # bind to all interfaces (if port is \u0026gt;= 0) port = 25223 # port for HTTPS enable_cert_lookup = true # enable looking for domain specific certificate files on disk service_email = \u0026#34;\u0026#34; # email address for registering with Let\u0026#39;s Encrypt. Set a value to enable automatic certs use_staging = true # use Let\u0026#39;s Encrypt staging server cert_location = \u0026#34;$CL_HOME/config/certificates\u0026#34; # where to look for existing certificate files storage_location = \u0026#34;$CL_HOME/run/certmagic\u0026#34; # where to cache dynamically created certificates Port 0 means bind to any available port. Port -1 means disable HTTPS access.\nTLS Certificates # In the default configuration, where service_email is empty, certmagic integration is disabled. The certificate handling behavior is:\n$CL_HOME/config/certificates is looked up for a crt and key file in the PEM format matching the domain name as passed to the server. If a matching certificate is found, that is used. If no domain specific certificate is found, then the default certificate default.crt and default.key are looked up. If found, that is used. If default certificate is not found, then a self-signed default certificate is auto created in the certificates folder. The intent is to allow custom certificates to be placed in the certificate folder, which will be used. If not found, a self-signed certificate is created and used. For example, if files example.com.crt and example.com.key are found in the certificates folder, those are used for example.com domain.\nEnable Automatic Signed Certificate # Clace uses the certmagic library for fully-managed TLS certificate issuance and renewal. Certmagic is disabled by default. To enable, the pre-requisites are:\nThe https config is using 443 as the port number. Running on privileged ports requires additional setup There is an DNS entry created pointing your host name or domain wildcard to the IP address of the host running the Clace server. This has to be done in your DNS provider config. Port 443 is reachable from the public internet. This has to be done in your infrastructure provider network settings. Once the pre-requisites are met, set the service_email config parameter to your email address. This enables certmagic based certificate creation. The config will look like:\n# HTTPS port binding related Config [https] host = \u0026#34;0.0.0.0\u0026#34; port = 443 enable_cert_lookup = true # enable looking for domain specific certificate files on disk service_email = \u0026#34;MY_EMAIL@example.com\u0026#34; # CHANGE to your email address use_staging = true # CHANGE to false for production cert_location = \u0026#34;$CL_HOME/config/certificates\u0026#34; storage_location = \u0026#34;$CL_HOME/run/certmagic\u0026#34; Test out the certificate creation by sending HTTPS requests to port 443. If the certificate is getting created, change use_staging to false. Let\u0026rsquo;s Encrypt has strict rate limits, use the staging config to ensure that the pre-requisites are met before using the production config.\nWith this config, certmagic is used to create certificates for all HTTPS requests. Self signed certificates and enable_cert_lookup property are not used when certmagic is enabled.\nPrivileged Ports # On Linux, binding to low ports is disabled for non-root users. To enable binding to port 80 for HTTP and 443 for HTTPS, run the command\nsudo setcap cap_net_bind_service=+ep /path/to/clace_binary This would be required after any new build or update of the Clace binary.\nNotes # Please provide a valid email address in service_email. This allows you to receive expiration emails and also allows the CA to contact you if required. Start the configuration with staging use_staging = true, change to production config use_staging = false after ensuring that DNS and networking is working fine. If port 0 is used, the service will bind to any available port. Look at the stdout or logs to find the port used. Clients would have to be updated after every server restarted to point to the new port. Only the TLS-ALPN challenge is enabled in Clace. The HTTP and DNS based challenges are not supported currently. If Clace is running behind a load balancer, ensure that the load balancer is doing TLS pass-through. If TLS termination is done in the load balancer, then the automatic certificate management done by Clace through certmagic will not work. ","date":null,"permalink":"/docs/configuration/networking/","section":"Docs","summary":"Clace uses unix domain sockets for client CLI requests. HTTP and HTTPS are used for application requests. Automatic signed certificate creation is supported for HTTPS.","title":"Ports and Certificates"},{"content":"Request Structure # The handler function is passed one argument which has the details about the API call. The fields in this structure are:\nProperty Type Notes AppName string The app name in the config AppPath string The path where the app is installed. If root, then empty string AppUrl string The url for the app root PagePath string The path for the current page. If root, then empty string PageUrl string The url for the current page Method string The HTTP method, GET/POST etc IsDev bool Is the app installed in dev mode IsPartial bool Is this an HTMX driven partial request RemoteIP string The Client IP address UrlParams dict The url parameters, if used in the url spec Form dict The form data, including body and query Query dict The url query data, as a string array PostForm dict The form data from the body Data dict The response from the handler function Accessing Inputs # Url Parameters # For a route defined like\nace.page(\u0026#34;/user/{user_id}/settings\u0026#34;, \u0026#34;index.go.html\u0026#34;) the url parameter user_id can be accessed in the handler\ndef handler(req) user_id = req.UrlParams[\u0026#34;user_id\u0026#34;] Wildcard parameters are allowed at the end of the route. These are defined as\nace.page(\u0026#34;/path/*\u0026#34;, \u0026#34;index.go.html\u0026#34;) and can be accessed as\ndef handler(req) user_id = req.UrlParams[\u0026#34;*\u0026#34;] Regexes are also allowed in the path, these are defined as ace.page(\u0026quot;/articles/{aid:^[0-9]{5,6}}\u0026quot;) and accessed as req.UrlParams[\u0026quot;{aid}\u0026quot;]. The route will match only if the regex matches.\nQuery String Parameters # Query string parameters can be accessed as\ndef handler(req) name = req.Query.get(\u0026#34;name\u0026#34;) name = name[0] if name else None The value for Query is an string array, since there can be multiple query parameters with the same name.\nForm Data # Form data can be accessed like\ndef handler(req) name = req.Form.get(\u0026#34;name\u0026#34;) name = name[0] if name else None The value for Form is an string array, since there can be multiple form parameters with the same name.\n","date":null,"permalink":"/docs/app/request/","section":"Docs","summary":"The Request structure passed into the handler function, handling argument and post data","title":"Request"},{"content":"Clace applications run in a sandbox environment with no direct access to the system or Clace service. All access is through plugins. When an application is installed, the admin can audit the application for what access is being requested. Only the permissions which are approved are allowed at runtime.\nSecurity Model # The security model used by Clace is:\nThe application code written in Starlark(python) and HTML templates is untrusted. The Clace service and plugin code (in Go) are trusted. The admin can audit and approve the access required by the untrusted application code when the app is being installed. After installation, further application code updates do not require any further audit, as long as no new permissions are required. If the updated app code requires any new permission, the new plugin call will fail at runtime with a permission error. The trust boundary is about what the application can do in the backend. The frontend code is sandboxed by the browser, there is no additional auditing implemented for the frontend code.\nUsecases # This security model allows for the following:\nUsers can download applications and run on their machine, without worrying about what operations the app can do on their system outside the audited permissions. Operations teams can install and approve applications. Further application updates can be handled by the development team, without requiring the operational admins to verify the updated code. As long as the application works within the originally defined permission boundary, application updates will continue to work. Application developers can use LLM powered automated code generation tools without worrying about the side-effects of the code. If the generated code tries to perform any operation not previously approved, it will fail. Sample Application # As an example, the disk usage analysis app requires two permissions\napp = ace.app(\u0026#34;Disk Usage\u0026#34;, pages=[ace.page(\u0026#34;/\u0026#34;, partial=\u0026#34;du_table_block\u0026#34;)], permissions=[ ace.permission(\u0026#34;exec.in\u0026#34;, \u0026#34;run\u0026#34;, [\u0026#34;du\u0026#34;]), ace.permission(\u0026#34;exec.in\u0026#34;, \u0026#34;run\u0026#34;, [\u0026#34;readlink\u0026#34;]) ], style=ace.style(\u0026#34;https://unpkg.com/mvp.css@1.14.0/mvp.css\u0026#34;), ) It requests permission to use the exec.in plugin to run two CLI commands, first being du and other being readlink. When installing the app\n$ ./clace app create /utils/disk_usage ./examples/disk_usage/ App audit results /utils/disk_usage : app2WPQHwr5ZpKELqh0TvP5YMSnbab Plugins : exec.in Permissions: exec.in.run [du] exec.in.run [readlink] App created. Permissions need to be approved an audit report is shown with these requests. To approve the requested permissions, the admin can do\n$ ./clace app approve /utils/disk_usage App audit: /utils/disk_usage Plugins : exec.in Permissions: exec.in.run [du] exec.in.run [readlink] App permissions have been approved. The approval can be done during the app create itself, in that case the app is installed and approved immediately. None of the plugin code runs during the app creation, even for calls at the global scope. If the audit report does not match expectations, the app can be deleted.\n$ ./clace app create --approve /utils/disk_usage ./examples/disk_usage/ App audit results /utils/disk_usage : app2WPQpws6C1mWb6BujYGOdWMnF1C Plugins : exec.in Permissions: exec.in.run [du] exec.in.run [readlink] App created. Permissions have been approved $ ./clace app delete /utils/disk_usage App deleted /utils/disk_usage Once the app is created, if the application code is updated to change the line from\nret = exec.run(\u0026#34;readlink\u0026#34;, [\u0026#34;-f\u0026#34;, current], process_partial=True) to\nret = exec.run(\u0026#34;rm\u0026#34;, [\u0026#34;-f\u0026#34;, current], process_partial=True) The app will fail at runtime with an error like\napp /utils/disk_usage is not permitted to call exec.in.run with argument 0 having value \u0026#34;rm\u0026#34;, expected \u0026#34;readlink\u0026#34;. Update the app or audit and approve permissions The app cannot be run until either the code change is reverted or the admin approves the new call to rm.\nRoadmap # The following enhancements are planned for the security model\nSecrets management is planned, in such a manner that the application can request access to specific secrets. The application can use the secret but will not have direct access to the secret value, it will work with a reference to the secret key. ","date":null,"permalink":"/docs/applications/appsecurity/","section":"Docs","summary":"Application Security and sandboxing model for Clace","title":"Application Security"},{"content":"The default configuration for the Clace server is:\nApplication management (admin APIs) are accessible locally only, using unix domain sockets An admin user account is used to access applications The admin user password has to be added to the server config file, or a random password is generated every time the server is restarted Applications can be change not require any authentication There is no user management support in Clace currently, the plan is to integrate with OAuth2 providers and SAML services for managing user access Admin Account Password # When the Clace server is started, it looks for the entry\n[security] admin_password_bcrypt = \u0026#34;\u0026#34; # the password bcrypt value in the config file. If the value is undefined or empty, then a random password is generated and is used as the admin password for that server session. The password being used is displayed on the stdout of the server startup. This will change on every restart.\nTo configure a fixed value for the admin user password, use the helper command\nclace password To generate a random password. This will print out the password and its bcrypt value to the screen. Save the password in your password manager and add the bcrypt has to your config file.\nTo use a particular value for the admin password, run\nclace password --prompt This will prompt for the password and print out the bcrypt hash to add to the config file.\nAdmin API Access # By default, the Clace client uses Unix domain sockets to connect to the Clace server. Admin API calls to manage applications are disabled over HTTP/HTTPS by default. Unix sockets work when the client is on the same machine as the server, the client does not need to pass any credentials to connect over unix sockets. See here for details about the client configuration.\nTo enable remote API calls, where the client is on a different machine from the server, the server needs to be changed to add the following:\n[security] admin_over_tcp = true If running the Clace client from a remote machine, the config options required for the client are:\nserver_uri = \u0026#34;https://\u0026lt;SERVER_HOST\u0026gt;:25223\u0026#34; admin_user = \u0026#34;admin\u0026#34; [client] admin_password = \u0026#34;\u0026#34; # Change to actual password skip_cert_check = false # Change to true if using self-signed certs These can be specified in a client config file or can be set in the CLI command line. All other config entries are ignored by the Clace client. Note that to connect to a Clace server over HTTP remotely, the server needs to be bound to the all interface(0.0.0.0), see here.\nIf server_uri is set to the https endpoint and the Clace server is running with a self-signed certificate, set skip_cert_check = true in config or pass --skip-cert-check=true in client commands to disable the TLS certificate check.\nApplication Security # See appsecurity for details about the application level sandboxing.\n","date":null,"permalink":"/docs/configuration/security/","section":"Docs","summary":"Clace Security related configuration","title":"Security"},{"content":"Response Data # The Response from the handler function is passed to the template to be converted to HTML. The handler response is accessible through .Data, or $Data if in another scope. Any python object can be used as the return value. Using a dictionary is recommended, so that error handling is easier. Adding a Error key in the response dict can indicate to the template that an error condition needs to be handled.\nFor example, a handler like\ndef handler(req): name = req.Query.get(\u0026#34;name\u0026#34;) if name: return {\u0026#34;Name\u0026#34;: name[0], \u0026#34;Error\u0026#34;: None} else: return {\u0026#34;Error\u0026#34;: \u0026#34;Name not specified\u0026#34;, \u0026#34;Name\u0026#34;: None} app = ace.app(\u0026#34;test\u0026#34;, pages = [ace.page(\u0026#34;/\u0026#34;)]) allows the template to handle the error by doing\n{{block \u0026#34;clace_body\u0026#34; .}} {{if .Data.Error}} \u0026lt;div style=\u0026#34;color: red\u0026#34;\u0026gt;{{.Data.Error}}\u0026lt;/div\u0026gt; {{else}} Hi {{.Data.Name}} {{end}} {{end}} Redirect Response # If the API needs to redirect the client to another location after a POST/PUT/DELETE operation, the handler function can return an ace.Redirect structure. The fields in this structure are:\nProperty Optional Type Default Notes url false string The url to redirect to code true int 303 The HTTP status code, 303 or 302 For example, this code does a 303 redirect after a POST API, which provides proper handing for update requests.\ndef create_game(req): level = req.Form[\u0026#34;level\u0026#34;] ret = http.post(SERVICE_URL + \u0026#34;/api/create_game/\u0026#34; + level[0]) return ace.redirect(req.AppPath + \u0026#34;/game/\u0026#34; + ret.json()[\u0026#34;GameId\u0026#34;]) Custom Response # In some cases, a custom response need to be generated, with special headers. Or the response needs to use a template different from the one defined in the route, which could happen in the case of an error. For such cases, a ace.Response structure can be returned by the handler. The fields in this structure are:\nProperty Optional Type Default Notes data false object The response data block true string Optional only if type is \u0026ldquo;json\u0026rdquo; type true string inherited from the route type definition If \u0026ldquo;json\u0026rdquo;, block is ignored code true int 200 HTTP status code retarget true string HX-Retarget header value, CSS selector to target, like \u0026ldquo;#error_id\u0026rdquo; reswap true string HX-Reswap, like \u0026ldquo;outerHTML\u0026rdquo; For example, this handler code uses retarget to handle errors by updating the html property which has id \u0026ldquo;gameErrorId\u0026rdquo;\nret = http.post(api_url).json() if ret.get(\u0026#34;Error\u0026#34;): return ace.response(ret, \u0026#34;game_error_block\u0026#34;, retarget=\u0026#34;#gameErrorId\u0026#34;) return fetch_game(req, game_id) This code returns a 404 with a custom body generated from a template block called \u0026ldquo;invalid_challenge_block\u0026rdquo;\nif challenge.get(\u0026#34;Error\u0026#34;): return ace.response(challenge, \u0026#34;invalid_challenge_block\u0026#34;, code=404) JSON Response # All responses are HTML by default, as required for building a proper Hypermedia client. There are some cases where data needs to be returned to the client in JSON format. The type property can be used for those cases. For example, this API returns JSON\nace.page(\u0026#34;/memory\u0026#34;, handler=memory_handler, type=\u0026#34;json\u0026#34;), Here, the response from the handler function is returned as JSON, no template is used. Also, in this handler, if there is a call to ace.Response, the type will default to \u0026ldquo;json\u0026rdquo; since that is the type specified at the route level. Mime type detection based on the Accept header is planned, it is not currently supported.\n","date":null,"permalink":"/docs/app/response/","section":"Docs","summary":"The response from the handler function, custom response and redirects","title":"Response"},{"content":"","date":null,"permalink":"/docs/app/","section":"Docs","summary":"Developing Clace applications, managing API routes and HTML templates","title":"Developing Applications"},{"content":"Clace uses Go HTML templates for returning data to the client. See here for an overview of the template syntax.\nThe Sprig template library functions are included automatically. Two functions from Sprig which are excluded for security considerations are env and expandenv.\nTwo extra functions are added for handling static file paths.\nstatic function # This function takes a file name and returns the url for a file in the static folder with a sha256 hash included in the file name. This approach is based on the hashfs library. If the static folder contains a file file1 with the content file1data, then a call to static \u0026quot;file\u0026quot; will return /test/static/file1-ca9e40772ef9119c13100a8258bc38a665a0a1976bf81c96e69a353b6605f5a7, assuming the app is installed at /test.\nThe returned file name has a hash based on the file contents. The file server used by Clace will serve aggressive cache headers Cache-Control: public, max-age=31536000 when this file is referenced by the browser. When the file contents change, the content hash will change and the file name will change. The files on disk are not renamed, only the filesystem used by the Clace server in memory sees the hashed file names.\nThis approach allows for a build-less system with the aggressive static asset caching. The usual approach for this requires the static file to be renamed to have the hash value in the file name on disk. This require a build step to do the file renaming. The hashfs approach can avoid the build step. The file hash computation and compression are done once, during app installation in prod mode. There is no runtime penalty for this. In dev mode, the file hashing is done during the api serving.\nfileNonEmpty function # The fileNonEmpty function returns a bool, indicating whether a static file with that non-hashed name is present and is not empty. This can be used to conditionally include style files if present.\nFor example\n{{ if fileNonEmpty \u0026#34;css/style.css\u0026#34; }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ static \u0026#34;css/style.css\u0026#34; }}\u0026#34; /\u0026gt; {{ end }} checks if the \u0026ldquo;css/style.css\u0026rdquo; file is present and not empty. If so, it is linked using the static function, which returns a hashed file name which can be cached aggressively.\nNote: The path passed to static and fileNonEmpty functions should not include static, it is automatically added. So use {{ static \u0026quot;css/style.css\u0026quot; }}, not {{ static \u0026quot;static/css/style.css\u0026quot; }} Template File Location # Templates are loaded once on app initialization. In dev mode, they are automatically reload on file updates. By default, the app source home directory is searched for template files. This can be changed by adding this directive in the ace.app config.\nsettings={ \u0026#34;routing\u0026#34;: {\u0026#34;template_locations\u0026#34;: [\u0026#34;*.go.html\u0026#34;, \u0026#34;templates/*.go.html\u0026#34;]} } the default is [\u0026quot;*.go.html\u0026quot;]. If additional directories are added, \u0026quot;*.go.html\u0026quot; still needs to present in the list since generated files are created in the app home directory. Also, all folders in the list need to contains at least one template file. File names have to be unique across folders. Files are referenced by their name, without the folder name, when used in template import directives.\nFile Contents # When using custom layout, the app developer has to create the index.go.html file. Adding a directive like:\n{{ template \u0026#34;clace_gen_import\u0026#34; . }} in the head section ensures that the auto generated clace_gen_import directives are loaded. This will include the style files, HTMX library and the live reload functionality will be enabled in dev mode.\nIn Clace layout mode (the default), the auto generated index_gen.go.html file is used. The app developer has to provide a clace_body block. It can be in any file, the convention is to use app.go.html. For example:\n{{block \u0026#34;clace_body\u0026#34; .}} Data is {{.Data}} {{end}} The .Data binding has the response as returned by the handler function for the route.\n","date":null,"permalink":"/docs/app/templates/","section":"Docs","summary":"HTML templates functions, static file handling and customizations","title":"Templates"},{"content":"Clace supports working with Classless CSS libraries and also with TailwindCSS and DaisyUI. To use this, add the directive\nstyle=ace.style(\u0026#34;daisyui\u0026#34;) in the app definition. The fields in the ace.style structure are:\nProperty Optional Type Default Notes library false string The library to use, url to classless library, \u0026ldquo;tailwindcss\u0026rdquo; or \u0026ldquo;daisyui\u0026rdquo; themes true string[] [] The daisyui themes to include disable_watcher true bool false Whether to disable the tailwind watcher process startup in dev mode Classless CSS # If the library property is a url, it should point to a publicly accessible style file. The style file is downloaded into the static/gen/css/style.css file. The file is automatically included as part of the clace_gen_import template.\nFor example,\nstyle=ace.style(\u0026#34;https://unpkg.com/mvp.css@1.14.0/mvp.css\u0026#34;), imports the MVP.css library. Since this is classless, no changes are required in the HTML templates.\nTailwindCSS # To use TailwindCSS, in app settings, add\nstyle=ace.style(\u0026#34;tailwindcss\u0026#34;) Tailwind CSS works by scanning the HTML files for class names, generating the corresponding styles and then writing them to a static CSS file. A watcher process is started when an app using Tailwind is loaded in dev mode. The output of the watcher is written to static/gen/css/style.css file. This file is automatically included as part of the clace_gen_import template.\nTo ensure that the tailwind watcher is started, the tailwind CLI needs to be installed manually. The standalone CLI can be used, that does not require npm, but that does not support DaisyUI integration.\nThe Clace server config file has the following entries:\n[system] tailwindcss_command = \u0026#34;npx tailwindcss\u0026#34; file_watcher_debounce_millis = 300 tailwindcss_command is the command use to start the watcher. If the standalone version is being used change to\n[system] tailwindcss_command = \u0026#34;/path/to/tailwindcss\u0026#34; file_watcher_debounce_millis is used to prevent repeated reloads of the application files during dev mode. On slower machine, this value might have to be increased, but setting it too high will cause the reload to be slower.\nDaisyUI # To use DaisyUI, in app settings, add\nstyle=ace.style(\u0026#34;daisyui\u0026#34;, themes=[\u0026#34;dark\u0026#34;]) Change to the preferred theme. DaisyUI is a good option to use to get great default styling for components, with the full flexibility of Tailwind. To use DaisyUI, the standalone version of TailwindCSS CLI cannot be used, npm version is required. To get this working, follow the installation instructions here. Clace takes care of creating the config files, the npx tailwindcss command should be setup manually. Using the CDN version of DaisyUI or Tailwind is not recommended since that will cause the style files to be large.\n","date":null,"permalink":"/docs/app/styling/","section":"Docs","summary":"CSS Styling, TailwindCSS, DaisyUI","title":"Styling"},{"content":"Clace supports importing JavaScript libraries as JavaScript Modules . To use this feature, add\nlibraries=[ace.library(\u0026#34;d3\u0026#34;, \u0026#34;7.8.5\u0026#34;)] in the app definition. The fields in the ace.library structure are:\nProperty Optional Type Default Notes name false string The name of the library to import version false string The version of the library args true string[] [] Arguments to pass to esbuild The args array uses the esbuild cli syntax. For example, passing args as [\u0026quot;--minify\u0026quot;] will enable minification for the imported module.\nTo directly download a library from a CDN to the static folder, add the url directly. For example,\nlibraries=[\u0026#34;https://unpkg.com/jquery@3.3.1/dist/jquery.min.js\u0026#34;] The HTMX library and its SSE extension are automatically downloaded.\nJavaScript Modules # JavaScript modules (also called ESM or ECMAScript Modules) are a way to import Javascript libraries dynamically, providing a unique namespace for all functions. Modules, once imported, can be used in the client code without requiring any build steps. See jvns.ca and simonwillison.net for notes about this approach. Clace tries to provide an easy interface to modules, converting npm packages to module format so that subsequent code changes do not require any build steps.\nWorkflow # The workflow when using modules in Clace for an app in dev mode is:\nIn you home directly, install nodejs Using npm, install package you want to use a modules. for example npm install d3 Add the ace.library entry in the app config. Clace will automatically run esbuild and import the package as a module into static/gen/esm Add an importmap in the head section of the html. Like here. \u0026lt;script type=\u0026#34;importmap\u0026#34;\u0026gt; { \u0026#34;imports\u0026#34;: { \u0026#34;d3\u0026#34;: \u0026#34;{{ static \u0026#34;gen/esm/d3-7.8.5.js\u0026#34;}}\u0026#34; } } \u0026lt;/script\u0026gt; Use the library as required in your client. Like here import * as d3 from \u0026#34;d3\u0026#34;; Creating the module is a one time step. The generated module can be checked into source code. On a new machine, to make code changes to the app, you do not need nodejs or npm to be installed.\nFor production deployment, no changes are required. Checkout the git repo containing the source code and create a Clace app. Clace will serve the static assets over HTTP/2 with content hash based caching. The assets are compressed for serving, there is no need usually for mimifying the modules.\nEsbuild Config # Clace includes esbuild, there is no need to install esbuild manually. The Clace server config has the entry\n[system] node_path = \u0026#34;\u0026#34; The node_path property is used by esbuild, these paths are searched for packages in addition to the node_modules directories in all parent directories. See esbuild docs for details. Paths should be separated with : on Unix and ; on Windows.\nIf you install the npm packages in your home directory, esbuild will pick up those without any additional configuration. Since each Clace project is importing the npm package as a module, you do not need to maintain separate node_modules for each Clace project.\nIf you do not want esbuild to create modules, set the node_path property in the server config to disable. You will have to manually download the module file into the static folder.\nNotes # The version number specified in the ace.library is used to create the file name under static/gen/esm. The actual package version depends on what was install using npm. Ensure that the same version is installed by npm as specified in the library config. Only the minify option for esbuild has been tested with Clace. Other options like chunking the files might not work currently. The JavaScript support is for running JS on the browser. There is no support for running JavaScript on the Clace server, the server runs only Go code and starlark applications. If an library url is specified, that is downloaded directly. There is no need for npm package in that case. ","date":null,"permalink":"/docs/app/javascript/","section":"Docs","summary":"JavaScript dependency handling, esbuild config","title":"JavaScript"},{"content":"","date":null,"permalink":"/blog/","section":"Clace Blog","summary":"","title":"Clace Blog"},{"content":"Clace: Platform for Easy Self-Hosted Web Applications # Clace is an open-source platform to enable easy development and deployment of self-hosted web applications. The goals for the Clace project are:\nEnable development and deployment of secure internal web applications. Simplify ongoing maintenance of such apps by removing build and dependency related issues. Updating an app after six months or six years should just work. Provide portable and flexible deployment options, allowing use on personal machine and also shared across teams. Use-cases # Clace is built to solve two different types of use-cases:\nCustom applications: With fully customizable UI, this would be similar to solutions like Retool. A low-code approach is used, with a focus on Hypermedia driven applications. Workflows: This would be similar to solutions like Rundeck. A way to automate internal applications, with a form based interface, with support for triggered and scheduled execution. One of the aims of Clace is to make it possible for everyone, especially backend engineers, to develop and use simple web interfaces. For use-cases where a CLI was developed previously, a Clace based UI could be built. The backend service could invoke the CLI command or directly call the internal API which need to be exposed. Development and use of simple web interfaces for all types of use-cases should be made easier with Clace.\nHow does it work? # Clace applications are configured in Starlark, which uses a subset of Python syntax. The API routes are defined to be Hypermedia first, using HTML templates to drive the UI interactions. Templates are written using Go HTML templates. HTMX is used for server interactions. The backend code runs in a security sandbox and every access to plugins need to be explicitly permitted. Application updates can be done with no build step required. Clace integrates with TailwindCSS/DaisyUI for styling and has esbuild built-in for ESM support.\nSecurity # The Starlark backend code for Clace runs in a sandbox, all external interactions need to go through plugins. The Clace platform implements a security sandbox at the plugin boundary. Applications define what operations they need to be able to perform. The platform enforces these permissions at runtime.\nThis security model enables the following:\nUsers can download applications and run on their machine, without worrying about what operations the app can do on their system outside the audited permissions. Operations teams can install and approve applications. Further application updates can be handled by the development team, without requiring the operational admins to verify the updated code. As long as the application works within the originally defined permission boundary, application updates will continue to work. Application developers can use LLM powered automated code generation tools without worrying about the side-effects of the code. If the generated code tries to perform any operation not previously approved, it will fail. The sandbox will ensure that the apps can do only authorized operations. This makes Clace an ideal target for LLM (like GPT) generated applications. The Clace platform will add the authentication/authorization, gitops based deployment and operational monitoring features on top of the generated app.\nCurrent Status # Clace is in a beta state currently. Custom application support is functional. Support for loading plugins dynamically is in progress. You can try out Clace (on OSX, Linux or Windows with WSL) by doing:\ncurl -L https://clace.io/install.sh | sh source $HOME/clhome/bin/clace.env clace server start \u0026amp; clace app create --approve /disk_usage github.com/claceio/clace/examples/disk_usage/ The app should be available at https://127.0.0.1:25223/disk_usage after allowing the self-signed certificate. admin is the username, use the password printed by the install script. See installation for details.\nFollow Along # You can keep in touch by these means:\nStar the repo at github.com/claceio/clace Sign up for Email updates Follow on Twitter Subscribe to the blog RSS feed Follow ClaceIO on LinkedIn Use discussions feature in Github or raise issues to provide feedback.\n","date":"1 November 2023","permalink":"/blog/intro/","section":"Clace Blog","summary":"Introducing the Clace project: A Platform for Breezy Self-Hosted Web Apps","title":"Introducing Clace"},{"content":"Goals # The goals Clace is being built to support are:\nEnable easy development and deployment of self-hosted web applications. Simplify ongoing maintenance of such apps by removing build and dependency related issues. Flexible deployment options, allowing use on personal machine and also shared across teams. App Development Features # The dev time features supported currently by Clace are:\nHypermedia driven backend API design, simplifying UI development. Live reload using SSE (Server Sent Events) with HTTP/2 for all application changes, backend and frontend. Automatic creation of ECMAScript modules using esbuild. Automatic download for JavaScript and CSS dependencies. Support for TailwindCSS and DaisyUI watcher integration. Template caching and automatic reload on changes. App Deployment Features # The deployment features supported currently by Clace are:\nBackend app code runs in a security sandbox, with allowlist based permissions. No build step, the development artifacts are ready for production use. Support for github integration, apps being directly deployed from github code. Database backed application file system, for atomic version updates and rollbacks. Zero downtime application updates. Scalable backend, all performance critical code is in Go, only application handler code is in Starlark. Support for domain based and path based routing at the app level. Virtual filesystem with content hash based file names backed by SQLite database, enabling aggressive static content caching. Brotli compression for static artifacts, HTTP early hints support for performance. Automatic SSL certificate creation based on certmagic. Staging mode for app updates, to verify whether code and config changes work on prod before making them live. Preview app creation support, for trying out code changes. Roadmap # Clace is early in its development. The feature roadmap for Clace is:\nSupport for OAuth2 based login. Support for SSO with SAML. All plugins are internal (built into Clace binary) currently. The plan is to move to an external plugin model, plugins being loaded dynamically using go-plugin. SQLite is used as the metadata storage currently. Support for postgres and other systems is planned. Support for workflow jobs, which would have a form based interface with limited customizability, but with support for triggered and scheduled execution. Support for application data persistance. UI interface for Clace admin operations. Record replay based automatic integration test creation. Record all responses at the plugin boundary and use that to replay integration test scenarios. This is speculative currently, depending on the how the external plugin model is implemented. Distributed agent model, where the Clace server does the initial routing but the actual application execution happens on remote worker nodes. This feature, when added, might use a different licensing model. This is also speculative currently. ","date":null,"permalink":"/features/","section":"Clace","summary":"Features supported by Clace","title":"Features"},{"content":"What is Clace? # Clace is an open-source (Apache-2.0 Licensed) project building a platform to easily develop and deploy self-hosted web applications. Clace provides a web application server focused on securely running multiple applications on a single installation. Applications are full stack, with a backend which can talk to external endpoints, the frontend can be auto generated forms or fully customizable web applications.\nProject Goals # The goal of this project is to make it easy for individuals and teams to develop and manage lightweight full stack applications in a secure manner. Fully configurable and secure self-hosted web applications with minimal code is the goal. Easy integrations to enable SSO/SAML based authentication and authorization controls, audit logs and integration with secrets manager for managing credentials are goals.\nA single developer should be able to manage the full application lifecycle, frontend and backend development, test automation and production deployment. Deployments should support a gitops like approach, with automatic preview environment to verify changes before making them live. It should be easy, for the original developer or a new developer, to make application code changes - after six months or after six years.\nClace aims to give a dynamic development environment for applications with automatic reload of code changes, while providing a performant and scalable platform which is operationally simple to manage.\nTerminology # Internal applications: Web applications built or downloaded for use by an individual or teams. For users, this could be apps to manage their machine, like monitor disk usage across folders. For teams, apps could automate common operations like managing resource limits, provisioning accounts etc. Sandboxing: Sandboxing is a security mechanism to ensure that an application stays within the rules set by the admin. If an application is configured to perform GET requests, trying to do a POST request from the application will fail until the admin authorizes the application to perform POST requests. Sandboxing is different from containers/jails. Those allow you to control at the network layer. Sandboxing allow more fine grained controls at the application API layer. Sandboxing allows usecases like allow GET but not POST, allow access to one database table but not to others etc. What\u0026rsquo;s with the name # The name Clace is a play on Command Line Ace, since an UI for command line applications is an initial target use-case. The name is pronounced like Place, with a C.\nWhy is there a need for such a platform? # There are tools like Rundeck and Jenkins which allow automating operational scripts. These have very limited UI customizability. At the other extreme, SaaS services like Retool which focus on internal tools development allow developing a customizable UI using no-code generators. These speed up the initial development experience to some extent but at the cost of operational complexity. Ongoing maintenance and updates for such low-code applications does not work well with general software development lifecycle practices. Most such tools use a heavy-weight single page application (SPA) based UI model.\nClace aims for a middle ground, aiming for easy self-hosting and operational simplicity while allowing fully customizable lightweight hypermedia driven applications, with a focus on security.\nWhat will success look like? # For the Clace project, success will mean:\nUsers can easily develop web applications for common use-cases Users can download and install such applications from the internet, without security being a concern Applications can be securely shared across teams, with operational concerns like SSO, audit logs etc automatically handled How is Clace implemented? # The way Clace tries to achieve these goals are:\nSingle binary web application server (in golang), with a set of plugins built in (also in golang) which allow access to external endpoints. The server is statically configured using a TOML file. Applications are configured using Starlark, which is a subset of Python. Python is an ideal glue language, Starlark is used to configure the application backend logic Multiple applications can be dynamically installed, an embedded SQLite database is used to store application metadata (Postgres support is in the roadmap). Path based routing, each app identified by a unique path. Also, domain based routing, which allows multiple domains to point to the same Clace instance, with path based routing being done independently for each domain. Automatic TLS certificate management for each domain to simplify deployments. A sandboxing layer is implemented at the Starlark(python) to Golang boundary, allowing the implementation of security and access control policies. Go code is trusted, Starlark code is untrusted. The application UI is implemented using Go HTML templates, with HTMX for interactivity. Go templates support context aware templating which prevents encoding related security issues. They also work well with the HTML fragments required for HTMX. No need to install any additional components like Python or NodeJS/NPM. Integration with tailwindcss-cli and esbuild (using the esbuild go library) is planned, but there are no plans to implement support for the full Javascript build tool ecosystem. What applications are suited for Clace? # Clace aims to provide a set of plugins which allow for features like Sandboxing for security and auto generation of tests. The plugins are implemented in Go and are exposed to the application through a Starlark interface. The initial plugins which will be implemented are HTTP client, command line application (CLI) runner, Slack, Github etc. The availability of plugins will limit which kinds of applications are suited for Clace.\nApplications suited for Clace currently would include:\nExposing a UI for a command line application Exposing a UI for a existing REST service (backend for frontend model) What applications are NOT suited for Clace? # Applications not suited for Clace would include:\nApplications which need to implement a complex database model, those would be better handled with Django/Rails/Spring Boot like frameworks. Applications which require a SPA style UI. This page gives a good overview of when a Hypermedia style UI would be a good fit. Since the Javascript build tooling support will be limited in Clace, Clace is not a backend to use when the intent is to develop a React/Angular/Vue SPA frontend. Clace is intended as platform to use when the UI can be a Hypermedia based one. Current Status # The development of Clace was started in April 2023. As of Sept 2023, basic functionality for the Clace server is functional. The current status is:\nClient and server (in a single binary) for service management and configuration Initial support for application development with Starlark based configuration Go HTML template loading and caching for request processing HTTP plugin for communicating with REST endpoints exec plugin for running system commands Built in admin account for local development Auto-sync (file system watcher) and Auto-reload using SSE (automatic UI refresh) for speeding up the application development cycle Admin functionality using unix domain sockets for security Application sandboxing checks to ensure only audited operations are allowed The next steps are to polish the application development interface, add support for loading eternal plugins, add support for SSO and RBAC etc. The aim is to do a beta release by October 2023 and a 1.0 release after that.\nWho is behind this project? # The project was started by Ajay Kidave. Ajay\u0026rsquo;s background has been in database systems and enterprise integration tools. Clace is an independent project that Ajay started while continuing to work as a consultant.\nWhat is the longer-term plan for Clace? # The current plan is to develop the open source project, with the aim of making Clace a great platform for managing internal applications. The service can currently scale up vertically, support for metadata storage in Postgres will be added which will enable horizontal scaling also.\nFor workload isolation and security reasons, some use cases might require a more distributed backend approach. An worker/agent mode is planned in the longer-term. This will mean the Clace server will not actually run the application code, the application code will run on distributed agents. The agent mode, when added, might use a different licensing model. Most regular use-cases should not require the agent mode; vertical and horizontal scaling should cover normal workloads. The core functionality of Clace, including SSO integration and all plugins, will remain Apache-2.0 licensed.\n","date":null,"permalink":"/about/","section":"Clace","summary":"Information about the use-cases for which Clace was built","title":"About Clace"},{"content":" App sandboxing for security Hypermedia driven web apps App config using Starlark Single binary deployment What is Clace? Clace is an Apache-2.0 licensed project building a platform to easily develop and deploy self-hosted web applications. Clace provides a web application server focussed on securely running multiple Hypermedia driven web applications on a single installation. Who is it for? Clace can be used by individuals to host web applications for use on their personal machines. Clace can also be used by teams to securely access applications on a shared server. Clace can also host publicly accessible web applications. What can/cannot it do? Clace can be used to securely develop the UI and backend APIs for internal applications. If you have an existing JSON based API, Clace supports building a hypermedia driven interface exposing that API. Developing a web UI for command line applications is another use-case. Clace does not have a persistence layer currently, so Clace works when there are existing APIs or applications which you want to expose as a web application. Clace is not a general purpose backend framework. How does it work? Clace allows applications to be configured in Starlark (subset of Python syntax). The API routes are defined to be Hypermedia first, using HTML templates to drive the UI interactions. Templates are written using Go HTML templates. HTMX is used for server interactions. The backend code runs in a security sandbox and access to plugins need to be explicitly permitted. There are no python or Javascript dependencies to install. No containers to create, no yaml files to manage. Application updates can be done with no build step required. Clace integrates with TailwindCSS/DaisyUI for styling and has esbuild built-in for ESM support. Installation To install, start the service and create an app, run: $ curl -L https://clace.io/install.sh | sh # Note down the generated password $ source $HOME/clhome/bin/clace.env $ clace server start \u0026 # Any new app can be installed by running $ clace app create --approve /disk_usage github.com/claceio/clace/examples/disk_usage/ The app should be available at https://localhost:25223/disk_usage. admin is the username, use the password printed by the install script. See service startup for details. Samples See documentation for steps to create Clace apps. See GitHub for sample application code. Demo Apps is an online hosted demo. Sign up for email updates Subscribe ","date":null,"permalink":"/","section":"Clace","summary":"App sandboxing for security Hypermedia driven web apps App config using Starlark Single binary deployment What is Clace?","title":"Clace"},{"content":"Clace is an open-source Apache-2.0 licensed project for easy development and deployment of self-hosted web apps. Clace provides a web application server focussed on securely running multiple applications on a single installation. Clace apps are Hypermedia driven full stack web applications.\n","date":null,"permalink":"/docs/","section":"Docs","summary":"Clace is an open-source Apache-2.","title":"Docs"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]