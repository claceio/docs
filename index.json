[{"content":"The various commands for managing Clace apps are\n$ clace NAME: clace - Clace client and server https://clace.io/ USAGE: clace [global options] command [command options] [arguments...] COMMANDS: server Manage the Clace server app Manage Clace apps preview Manage Clace preview apps account Manage Clace accounts version Manage app versions password Generate a password bcrypt config entry help, h Shows a list of commands or help for one command $ clace app NAME: clace app - Manage Clace apps USAGE: clace app command [command options] [arguments...] COMMANDS: create Create a new app list List apps delete Delete an app approve Approve app permissions reload Reload the app source code promote Promote the app from staging to production update Update Clace apps settings help, h Shows a list of commands or help for one command The app management subcommands are under the app command. The preview command manages preview app for an app and version command manages versions for an app. The account command is for managing accounts for an app.\nApp Management #All the app management subcommands except create take a glob pattern, so multiple apps can be updated using one command. Use the --dry-run option with any update CLI call to verify if the options specified are correct before the actual run. No database changes are committed during dry-run and no changes are done in memory.\nGlob Pattern #The reload/delete/promote/approve/list commands accept a glob pattern. example.com:** will match apps under the example.com domain. *:** will match all apps in all domains, all is a shortcut for this. When using glob patterns, place the pattern inside double-quotes to avoid issues with shell star expansion. For example, \u0026quot;example.com:**\u0026quot;\nThe default for app list command is to list all apps. All other commands require an glob pattern to be specified explicitly.\nWhen multiple apps are being updated, if any one app fails, the whole operation is rolled back. This allows for atomic updates across multiple applications.\nApp Listing #Use the app list command to list apps. If the --internal option is used, then the internal staging and preview apps for each matched prod app are also listed.\n$ clace app list Id Type Version Auth GitInfo Domain:Path SourceUrl app_prd_2d3kCRk43FOuIGy979NbBWakRMm PROD 3 NONE main:9ce5e1adfc28983f7894 memory.demo.clace.io:/ github.com/claceio/clace/examples/memory_usage/ app_prd_2d3kCZ28w6VIzoXMsT9yldwijxL PROD 3 NONE main:9ce5e1adfc28983f7894 cowbull.co:/ github.com/claceio/clace/examples/cowbull app_prd_2d3kCjmw8ldQ2LaOd0CLmWXDApq PROD 3 NONE main:9ce5e1adfc28983f7894 / github.com/claceio/clace/examples/demo app_prd_2d3kKVvSsSgUHqtNGZaD95NuLK3 PROD 3 NONE main:9ce5e1adfc28983f7894 du.demo.clace.io:/ github.com/claceio/clace/examples/disk_usage/ app_prd_2d6KcZmNwHIB8cSzNCotqBHpeje PROD 5 NONE main:ed7545ae739dfe85140a utils.demo.clace.io:/bookmarks github.com/claceio/apps/utils/bookmarks $ clace app list -i Id Type Version Auth GitInfo Domain:Path SourceUrl app_prd_2d3kCRk43FOuIGy979NbBWakRMm PROD 3 NONE main:9ce5e1adfc28983f7894 memory.demo.clace.io:/ github.com/claceio/clace/examples/memory_usage/ app_stg_2d3kCRk43FOuIGy979NbBWakRMm STG 3 NONE main:9ce5e1adfc28983f7894 memory.demo.clace.io:/_cl_stage github.com/claceio/clace/examples/memory_usage/ app_prd_2d3kCZ28w6VIzoXMsT9yldwijxL PROD 3 NONE main:9ce5e1adfc28983f7894 cowbull.co:/ github.com/claceio/clace/examples/cowbull app_stg_2d3kCZ28w6VIzoXMsT9yldwijxL STG 3 NONE main:9ce5e1adfc28983f7894 cowbull.co:/_cl_stage github.com/claceio/clace/examples/cowbull app_prd_2d3kCjmw8ldQ2LaOd0CLmWXDApq PROD 3 NONE main:9ce5e1adfc28983f7894 / github.com/claceio/clace/examples/demo app_stg_2d3kCjmw8ldQ2LaOd0CLmWXDApq STG 3 NONE main:9ce5e1adfc28983f7894 /_cl_stage github.com/claceio/clace/examples/demo app_prd_2d3kKVvSsSgUHqtNGZaD95NuLK3 PROD 3 NONE main:9ce5e1adfc28983f7894 du.demo.clace.io:/ github.com/claceio/clace/examples/disk_usage/ app_stg_2d3kKVvSsSgUHqtNGZaD95NuLK3 STG 3 NONE main:9ce5e1adfc28983f7894 du.demo.clace.io:/_cl_stage github.com/claceio/clace/examples/disk_usage/ app_prd_2d6KcZmNwHIB8cSzNCotqBHpeje PROD 5 NONE main:ed7545ae739dfe85140a utils.demo.clace.io:/bookmarks github.com/claceio/apps/utils/bookmarks app_stg_2d6KcZmNwHIB8cSzNCotqBHpeje STG 5 NONE main:ed7545ae739dfe85140a utils.demo.clace.io:/bookmarks_cl_stage github.com/claceio/apps/utils/bookmarks Use the app version command to list versions for particular apps. This command works on prod app or staging app specifically.\n$ clace version list utils.demo.clace.io:/bookmarks_cl_stage Active Version Previous CreateTime GitCommit GitMessage 1 0 2024-03-01 19:59:27 +0000 UTC 86385ff67deab288c362 Updated bookmarks app 2 1 2024-03-01 20:00:20 +0000 UTC 86385ff67deab288c362 Updated bookmarks app 3 2 2024-03-01 20:16:08 +0000 UTC 86385ff67deab288c362 Updated bookmarks app 4 3 2024-03-02 00:12:28 +0000 UTC 8080fcfe6be832a1f6f5 Update styling for bookmarks app =====\u0026gt; 5 4 2024-03-02 00:23:35 +0000 UTC ed7545ae739dfe85140a Update styling for bookmarks app $ clace version list utils.demo.clace.io:/bookmarks Active Version Previous CreateTime GitCommit GitMessage 1 0 2024-03-01 19:59:27 +0000 UTC 86385ff67deab288c362 Updated bookmarks app 2 1 2024-03-01 20:00:20 +0000 UTC 86385ff67deab288c362 Updated bookmarks app =====\u0026gt; 5 2 2024-03-02 00:23:35 +0000 UTC ed7545ae739dfe85140a Update styling for bookmarks app The app version switch command can be used to switch versions, up or down or to particular version. The app version revert command can be used to revert the last change. app promote makes the prod app run the same version as the current staging app.\nIn the above listing, the staging app has five versions. Three of those (1,2 and 5) were promoted to prod. app version switch utils.demo.clace.io:/bookmarks_cl_stage down will change the stage app to version 4. app version switch utils.demo.clace.io:/bookmarks down will change the prod app to version 2. After that, app promote utils.demo.clace.io:/bookmarks will change prod to also be at version 4, same as stage.\nA star, like PROD* in the app list output indicates that there are staged changes waiting to be promoted. That will show up any time the prod app is at a different version than the stage app.\nApp Authentication #By default, apps are created with the system authentication type. System auth uses admin as the username. The password is displayed on the screen during the initial setup of the Clace server config.\nTo change app to be un-authenticated, add --auth-type none to the app create command. After an app is created, the auth type can be changed by running app update auth-type /myapp none. OAuth based authentication is also supported, see authentication for details.\nNote: Changes done to the app settings using the app update command are not staged or versioned, they apply immediately to the stage/prod/preview apps. App settings are fundamental properties of the app, like what authentication type to use, what git auth key to use etc.\nAll other changes done to app metadata (like account linking, permission approval and code reload) are staged before deployment. Use the --promote option to promote the change after applying it on the staging app. When a promotion is done, all previously staged changes for that app are promoted, not just the most recent change.\n","date":null,"permalink":"/docs/applications/overview/","section":"Docs","summary":"Overview of managing Clace applications","title":"App Management Overview"},{"content":"This pages provide a overview of how to start with Clace and provides links to documentation pages with more details.\nInstallation #To install the latest release build, run the install script on Linux, OSX and Windows with WSL. Note down the password printed. Add the env variables as prompted and then start the service.\ncurl -L https://clace.io/install.sh | sh source $HOME/clhome/bin/clace.env clace server start \u0026amp; clace app create --approve /disk_usage github.com/claceio/app/system/disk_usage/ The app should be available at https://127.0.0.1:25223/disk_usage after allowing the self-signed certificate. admin is the username and use the password printed by the install script.\nSee installation for details. See config options for configuration options. To enable Let\u0026rsquo;s Encrypt certificates, see Automatic SSL.\nOn Windows without WSL, download the release binary zip from releases or install from source if you have go installed.\nManaging Applications #Multiple applications can be installed on a Clace server. Each app has a unique path and can be managed separately. The app path is made up of domain_name:url_path. If no domain_name is specified during app creation, the app is created in the default domain. The default domain is looked up when no specific domain match is found. See app routing for details about routing.\nFor local env, url based routing is easier, since wildcard DNS is not available by default for the localhost domain. For production deployment, if wildcard DNS is setup, that makes domain routing easy. Apps can be hosted on multiple unrelated domains on one Clace server.\nApp Installation #To install apps, run\nclace app install --approve /disk_usage github.com/claceio/apps/system/disk_usage This is installing the system/disk_usage app from the main branch of the claceio/apps repo on GitHub. The app is installed for the default domain, to the /disk_usage path. Opening https://127.0.0.1:25223/disk_usage will make Clace initialize the app and show the app home page.\nThe /disk_usage/* path is now reserved for API\u0026rsquo;s under this app. No new apps can be installed under the /disk_usage/ path, but /disk_usage2 is available. Similarly, installing an app under / path means no new apps can be installed for the default domain. If the app code is available locally on Clace server node, the app install can be done directly with the local disk path:\nclace app install --approve /disk_usage_local ./diskapp When developing an app, the source code for the app has to be present locally. To install an app in dev mode, add the --dev option.\nclace app install --dev --approve /disk_usage_dev ./diskapp In dev mode, source code changes are picked up immediately and the app is live reloaded. For non-dev (prod) apps, app reload has to be done to pick up changes, from local disk or from git.\nclace app reload --approve --promote \u0026#34;/disk_usage*\u0026#34; For apps created from GitHub source, app reload will pick up the latest changes from the branch specified during app create (default is main). For apps created from local disk sources, the reload loads from the folder originally used during the create. For non-dev apps, the source code is loaded into the SQLite metadata database managed by the Clace server.\nApp Security #Application config is specified in Starlark code in the app.star file. By default, the app does not have any permissions. All external actions an app can perform are done through plugin API calls. Every plugin API call needs to be approved before it is allowed. This allows for multiple apps to run on the Clace server without interfering with each other.\nTo approve an app permissions, run\nclace app approve /disk_usage The --approve option can be specified during the app create and app reload command to automatically approve the permissions.\nStaged Deployments #For dev mode apps, there is just one app. For a prod mode app, creating the app creates a staging app and the actual production app. All config and code changes are applied on the staging mode app first, and then manually promoted using app promote or automatically, if --promote option is specified for the app reload.\nThe app list command lists all the apps for the specified glob pattern. By default, it lists only the dev and prod apps. To list the staging apps also, add the --internal option to app list. all is a shortcut for *:**, which means all apps in all domains. For example:\nclace app list --internal all lists all the apps and internal apps for each app. clace app list \u0026quot;example.com:**\u0026quot; lists the main apps for the example.com domain.\nThe staging app can be used to verify whether changes are working before the production app is updated. The staging app is accessible by suffixing _cl_stage at the end of the prod app path. So for an app at https://example.com/, the staging url is https://example.com/_cl_stage. For an app at /utils/app1, the staging app url is /utils/app1_cl_stage.\nTo promote changes from staging to prod, run:\nclace app promote all or clace app promote \u0026quot;/disk_usage*\u0026quot; to promote specific apps. Use the --dry-run option to verify changes before they are actually applied.\nLifecycle without Git #If not using git, a workflow would be:\nCreate a dev mode app, like clace app create --dev --approve /myapp_dev ~/myappcode Create a prod mode app, like clace app create --approve /myapp ~/myappcode As code changes are saved to disk, the changes are immediately live at https://localhost:25223/myapp_dev When code is in a stable state, run clace app reload /myapp. This will update the staging app with the most recent code from ~/myappcode folder. The staging app is available at https://localhost:25223/myapp_cl_stage for verification. To promote the code to prod, run clace app promote /myapp. The staged code is promoted to prod, live at https://localhost:25223/myapp. Having a staging environment helps catch issues related to account setup (which endpoint is pointed to etc) and other config issues before the changes are live on prod.\nLifecycle With Git #If using git, a workflow would be:\nCreate a dev mode app, like clace app create --dev --approve /myapp_dev ~/myappcode Create a prod mode app, like clace app create --approve /myapp github.com/myorg/repo As code changes are saved to disk, the changes are immediately live at https://localhost:25223/myapp_dev When code is in a stable state, check in the dev code to git. Run clace app reload /myapp. This will update the staging app with the most recent code from main branch in git. The staging app is live at https://localhost:25223/myapp_cl_stage. Verify the functionality of the staging app. To promote the code to prod, run clace app promote /myapp. The staged code is promoted to prod, live at https://localhost:25223/myapp. App Listing #Use clace app list to get list of installed app. By default, all apps are listed. Use a glob pattern like example.com:** to list specific apps. Pass the --internal or -i option to list to include the internal apps in the app listing. The pattern matches the main apps, and if the internal option is specified, the matched app\u0026rsquo;s linked apps are also listed.\nUse clace version list to get list of versions for an app. clace version switch allows switching between versions. The version command can be run separately on the staging app and prod app, like clace version list /myapp_cl_stage and clace version list /myapp. The current version is indicated in the output.\n$ clace version list /dugit Active Version Previous CreateTime GitCommit GitMessage 1 0 2024-02-16 19:39:05 +0000 UTC 03ccaa35927667977646 Added version file listing support 2 1 2024-02-16 19:55:51 +0000 UTC 03ccaa35927667977646 Added version file listing support =====\u0026gt; 3 2 2024-02-16 21:18:16 +0000 UTC c00d7b1e99712de13745 Added version switching support $ clace version list /dugit_cl_stage Active Version Previous CreateTime GitCommit GitMessage 1 0 2024-02-16 19:39:05 +0000 UTC 03ccaa35927667977646 Added version file listing support 2 1 2024-02-16 19:54:22 +0000 UTC 03ccaa35927667977646 Added version file listing support 3 2 2024-02-16 20:38:44 +0000 UTC c00d7b1e99712de13745 Added version switching support =====\u0026gt; 4 3 2024-02-16 21:18:42 +0000 UTC c00d7b1e99712de13745 Added version switching support $ clace app list -i /dugit Id Type Version Auth GitInfo Domain:Path SourceUrl app_prd_2cSkPeHiATfH46pcUX8EdZqdWQb PROD* 3 SYST main:c00d7b1e99712de13745 /dugit github.com/claceio/clace/examples/disk_usage app_stg_2cSkPeHiATfH46pcUX8EdZqdWQb STG 4 SYST main:c00d7b1e99712de13745 /dugit_cl_stage github.com/claceio/clace/examples/disk_usage In the above listing, the staging app is on version 4, prod app on version 3. The \u0026ldquo;*\u0026rdquo; in the app list output indicates that the prod app has staged changes waiting to be promoted. Running clace app promote /dugit will update prod with the staged changes.\nDeveloping Apps #Clace apps are written using Starlark and Go HTML templates. Starlark is a subset of Python, it is easy to pick up even if you are not familiar with Python. Go HTML templates are used by tools like Hugo and Helm.\nSee overview for a quick start overview on developing Clace applications.\n","date":null,"permalink":"/docs/quickstart/","section":"Docs","summary":"Quick Start guide on using Clace","title":"Quick Start"},{"content":"Plugins provide an API for Clace Starlark code to call out to external systems. Plugins are implemented in Go. Every plugin API calls needs to be in the approved list for it to be permitted. See security for an overview of the security model.\nEach plugin is identified by a unique name, like store.in or exec.in. Plugins ending with .in are internal plugins, built into the Clace binary. Support for external plugins which are loaded dynamically is currently in progress.\nPlugin Usage #To use a plugin, load it using\nload(\u0026#34;http.in\u0026#34;, \u0026#34;http\u0026#34;) This adds http to the namespace for the app. To make a call to the plugin, first add the permissions to the app config.\npermissions=[ ace.permission(\u0026#34;http.in\u0026#34;, \u0026#34;get\u0026#34;), ace.permission(\u0026#34;http.in\u0026#34;, \u0026#34;post\u0026#34;) ], Run clace app approve /myapp to authorize the app to call the get and post methods on the http plugin.\nIn the app handler code, do\nret = http.get(SERVICE_URL + \u0026#34;/api/challenge/\u0026#34; + challenge_id) if not ret: return ace.response(ret.error, \u0026#34;invalid_challenge_id\u0026#34;, code=404) At runtime, Clace will check if the get call is authorized. If so, the call to the plugin will be performed.\nResponse Handling #All plugin API calls return a plugin_response structure. The fields in this are\nerror The error message string, empty string if no error error_code The error code integer, zero if no error value The actual return value for the plugin API call. The datatype for this depends on the API, check the API documentation for details. To check the error status of an API call:\nCheck boolean value for the return. If false, that indicates an error which can be returned. If no error, get the value property and continue with processing For example,\nret = http.get(\u0026#34;https://localhost:9999/test\u0026#34;) if not ret: # error condition return ace.response(ret, \u0026#34;error_block\u0026#34;) # success print(ret.value.json()) # ret.value is the return value. The http plugin response has a json() function An alternate way to write the error check is\nret = http.get(\u0026#34;https://localhost:9999/test\u0026#34;) if ret.error: # error condition return ace.response(ret, \u0026#34;error_block\u0026#34;) # Success print(ret.value.json()) Automatic Error Handling #Clace supports automatic error handling, so that the handler functions do not have to check the error status of every plugin API call. The way this is implemented is such that if no explicit error handling is done, then the automatic error handling kicks in. If explicit error handling is done, then automatic error handling is not done. See bookmarks app for an example of how the automatic error handling can be used.\nIf the error_handler function is defined, then error handling is automatic. The manual error checking works the same as mentioned above. But if no manual error checking is done, then the Clace platform will automatically call the error_handler function. The error_handler is defined as:\ndef error_handler(req, ret): if req.IsPartial: return ace.response(ret, \u0026#34;error\u0026#34;, retarget=\u0026#34;#error_div\u0026#34;, reswap=\u0026#34;innerHTML\u0026#34;) else: return ace.response(ret, \u0026#34;error.go.html\u0026#34;) When error_handler is defined and no explicit error checks are done then the automatic error handling happens in these three cases:\nValue Access When the response value is accessed Next API call When the next plugin API call happens (to any plugin function) Handler Return When the handler function returns Value Access #If the handler code is\nret = http.get(\u0026#34;https://localhost:9999/test\u0026#34;) print(ret.value.json()) If the get API had succeeded, then the value property access will work as usual. But if the get API had failed, then the value access will fail and the error_handler will be called with the original request and the error response.\nNext API Call #If the value is not being accessed, then the next plugin call will raise the error. For example, if the handler code is\nstore.begin() bookmark = store.select_one(table.bookmark, {\u0026#34;url\u0026#34;: url}).value The response of the begin API is not checked. When the next select_one API is called, if the previous begin had failed, the select_one API will raise the previous API calls error before the select_one executes.\nHandler Return #If the handler code is\ndef insert(req): store.begin() book = doc.bookmark(\u0026#34;abc\u0026#34;, []) store.insert(table.bookmark, book) store.commit() Assume all the API calls had succeeded and then the commit fails. Since the value is not accessed and there is not plugin API call after the commit call, the Clace platform will raise the error after the handler completes since the commit had failed.\nOverriding Automatic Error Handling #The automatic error handling is great for handling the unusual error scenarios. For the error scenarios which are common, like a database uniqueness check failure, the error handing can be done explicitly in the handler code. If the handler code is\nret = store.insert(table.bookmark, new_bookmark) if ret.error: return ace.response(ret, \u0026#34;error.go.html\u0026#34;) The automatic error handling will not be invoked in this case since the ret.error is being checked. Checking the truth status of ret also will disable the automatic error handling:\nret = store.insert(table.bookmark, new_bookmark) if not error: return ace.response(ret, \u0026#34;error.go.html\u0026#34;) Note: The automatic error handling is very useful, but is needs to be enabled manually. When developing a new app, first define the error_handler and test it for the partial and full page scenarios. After that, all the subsequent handler code does not have to handle errors unless specific handling is required. Plugin Accounts #Some plugins like exec.in do not require any account information. Others like store.in need some account information. The account configuration for a plugin is loaded from the Clace config file clace.toml. For example, the default configuration for store.in is here, which contains:\n[plugin.\u0026#34;store.in\u0026#34;] db_connection = \u0026#34;sqlite:$CL_HOME/clace_app.db?_journal_mode=WAL\u0026#34; Any application using the store.in plugin will by default use the $CL_HOME/clace_app.db sqlite database. To change the default account config used by apps, update clace.toml and restart the Clace server. For example, adding the below will overwrite the default store.in config for all apps.\n[plugin.\u0026#34;store.in\u0026#34;] db_connection = \u0026#34;sqlite:/tmp/clace_app.db?_journal_mode=WAL\u0026#34; Account Linking #If specific account config is required for an app, then the app can be linked to a specific account config. First add a new account config by adding in clace.toml\n[plugin.\u0026#34;store.in#tmpaccount\u0026#34;] db_connection = \u0026#34;sqlite:/tmp/clace_app.db?_journal_mode=WAL\u0026#34; For an app using store.in, run clace account link --promote /myapp store.in tmpaccount\nThis links the myapp app to use the tmpaccount account.\nNamed Account #In addition to using account linking, the plugin code itself can point to specific accounts. For example, if the app code has\nload(\u0026#34;http.in#google\u0026#34;, \u0026#34;googlehttp\u0026#34;) then the app will use the http.in#google account config by default. This also can be overridden using account links, by running clace account link --promote /myapp http.in#google myaccount\nThis approach is useful if an app has to access multiple accounts for the same plugin. The account linking approach is recommended for normal scenarios.\nClace apps aim to be portable across installations, without requiring code changes. Using account config allows the app code to be independent of the installation specific account config.\n","date":null,"permalink":"/docs/plugins/overview/","section":"Docs","summary":"Overview of how plugins work, how to use them","title":"Plugin Overview"},{"content":"Clace applications implement a Hypermedia driven approach for developing web applications. Applications return HTML fragments as API response using Go html templates. The UI uses HTML enhanced with hypermedia controls using the HTMX library to implement user interactions.\nThe backend API routes and dependencies like CSS library, JavaScript modules etc are configured using Starlark configuration. Any custom API handling required is implemented in handler functions also written in Starlark. Starlark is a subset of python, optimized for application configuration usecases.\nStructure #The structure of a Clace application is:\nOne Clace application per folder, static sub-folder contain static assets An app.star Starlark file, defining the application configuration Predefined builtins, accessed through the ace namespace A global called app, created using app = ace.app() call An optional default handler function called handler. Other handlers are referenced in the route config An optional error handler function called error_handler. Defining the error_handler enables automatic error handling An html template file called index.go.html if using custom layout If not using custom layout, an html template block called clace_body defined in any *.go.html file, for example app.go.html App Lifecycle #The Clace app development lifecycle is:\nCreate a folder for the app, with the app.star file and templates. Start the Clace server. Create an app using clace app create --dev. This runs the app in dev mode. In dev mode, some additional files are generated, with _gen in the file name. CSS dependencies and JavaScript modules are downloaded into the static folder. After the app development is done, the whole app folder can be checked into source control. There is no build step. Create a production app, clace app create, without the --dev. The app is now live. The Clace server can host multiple applications, each application has a dedicated path and optionally a dedicated domain. Examples #Simple Text App #The hello world app for Clace is an ~/myapp/app.star file containing:\ndef handler(req): return \u0026#34;hello world\u0026#34; app = ace.app(\u0026#34;hello\u0026#34;, pages = [ace.page(\u0026#34;/\u0026#34;, type=ace.TEXT)] ) Run clace app create --auth-type=none /hello ~/myapp. After that, the app is available at /hello\n$ curl localhost:25222/hello hello world The default response type is ace.HTML. ace.TEXT and ace.JSON are the other options. The data returned by the handler function is converted to the type format specified in the API.\nCustom Layout HTML App #To return HTML response, a HTML template file named *.go.html is required. Create an ~/myapp2/app.star file containing\napp = ace.app(\u0026#34;hello2\u0026#34;, custom_layout=True, pages = [ace.page(\u0026#34;/\u0026#34;)] ) and an ~/myapp2/index.go.html file containing\nhello world2 Run clace app create --auth-type=none /hello2 ~/myapp2. After that, the app is available at /hello2\n$ curl localhost:25222/hello2 hello world2 The ~/myapp2/index.go.html can be updated to have a complete HTML page. Use the command clace app reload --promote /hello2 to pick up changes. This app is using custom_layout=True which means the app developer has to provide the complete HTML.\nDefault Layout HTML App #The default is custom_layout=False meaning app developer has to provide only the HTML body, Clace will automatically generate the rest of the HTML. For using the auto generated HTML templates, the app has to be created in dev mode using the --dev option.\nCreate an ~/myapp3/app.star file containing\napp = ace.app(\u0026#34;hello3\u0026#34;, pages = [ace.page(\u0026#34;/\u0026#34;)] ) and an ~/myapp3/app.go.html file containing\n{{block \u0026#34;clace_body\u0026#34; .}} hello world3 {{end}} Run clace app create --auth-type=none --dev /hello3 ~/myapp3. After that, the app is available at /hello3. Note that the --dev option is required for the index_gen.go.html file to be generated.\nThe name of the app is hello3. There is only one route defined, for page /, which shows a HTML page with the name of the app. The body is generated from the contents of the app.go.html file. A more verbose way to write the same app config would be\napp = ace.app(name=\u0026#34;hello3\u0026#34;, custom_layout=False, pages = [ace.page(path=\u0026#34;/\u0026#34;, full=\u0026#34;index_gen.go.html\u0026#34;)] ) Complete App #To create an app with a custom HTML page which shows a listing of files in your root directory, create an ~/myapp4/app.star file with\nload(\u0026#34;exec.in\u0026#34;, \u0026#34;exec\u0026#34;) def handler(req): ret = exec.run(\u0026#34;ls\u0026#34;, [\u0026#34;-l\u0026#34;, \u0026#34;/\u0026#34;]) if ret.error: return {\u0026#34;Error\u0026#34;: ret.error, \u0026#34;Lines\u0026#34;: []} return {\u0026#34;Error\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;Lines\u0026#34;: ret.value} app = ace.app(\u0026#34;hello1\u0026#34;, custom_layout=True, pages = [ace.page(\u0026#34;/\u0026#34;)], permissions = [ace.permission(\u0026#34;exec.in\u0026#34;, \u0026#34;run\u0026#34;, [\u0026#34;ls\u0026#34;])] ) and an ~/myapp4/index.go.html file with\n\u0026lt;!doctype html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;File List\u0026lt;/title\u0026gt; {{ template \u0026#34;clace_gen_import\u0026#34; . }} \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; {{ .Data.Error }} {{ range .Data.Lines }} {{.}} \u0026lt;br/\u0026gt; {{end}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Run clace app create --auth-type=none --dev --approve /hello4 ~/myapp4. After that, the app is available at /hello4. Note that the --dev option is required for the clace_gen_import file to be generated which is required for live reload.\nThis app uses the exec plugin to run the ls command. The output of the command is shown when the app is accessed. To allow the app to run the plugin command, use the clace app approve command.\nAutomatic Error Handling #To enable automatic error handling (recommended), add an error_handler function like:\ndef error_handler(req, ret): if req.IsPartial: return ace.response(ret, \u0026#34;error\u0026#34;, retarget=\u0026#34;#error_div\u0026#34;, reswap=\u0026#34;innerHTML\u0026#34;) else: return ace.response(ret, \u0026#34;error.go.html\u0026#34;) More examples #There are more examples here. The disk_usage example uses the MVP classless library for styling and shows a basic hypermedia flow. The cowbull game examples has multiple pages, each page with some dynamic behavior. Clace does not currently have a persistence layer. The cowbull game depends on another service for data persistence, so it is implementing a backend for frontend pattern. For styling, it uses the DaisyUI component library for Tailwind CSS. These two examples work fine with Javascript disabled in the browser, falling back to basic HTML without any HTMX extensions.\nThe memory_usage example uses the d3 library to show a interactive display of the memory usage for processes on the machine. The plot library is automatically imported as a ECMAScript module and the custom javascript code works with a JSON api on the backend. The default in Clace is hypermedia exchange, JSON can be used for data API\u0026rsquo;s.\nThese examples are live on the demo page.\n","date":null,"permalink":"/docs/app/overview/","section":"Docs","summary":"Overview of the Clace application development model","title":"Overview"},{"content":"Request Routing #The Clace server can host multiple applications simultaneously. Each application gets a dedicated path, the application can use all sub-paths within that without conflicts with other applications.\nWhen an application is created, a path needs to be specified and a domain can be optionally specified. Routing for application requests is done based on domain and path. The domain is the namespace within which the paths are resolved.\nConsider this scenario:\nApp A is installed at /utils/appA App B is installed at /appB App C is installed at the root level / for domain example.com, example.com:/ App D is installed at /test for test.mydomain.com, test.mydomain.com:/test App E is installed at /test2 for test.mydomain.com, test.mydomain.com:/test2 For every API call, the Clace server first checks whether the API call is against a domain namespace which is currently configured in Clace. If so, applications matching that domain are looked up. If no matching domain is located, then the default namespace (with no domain) is looked up.\nFor the above scenario:\nRequests to /utils/appA/* for any domain other than example.com and test.mydomain.com will go to App A. Requests to /appB/* for any domain other than example.com and test.mydomain.com will go to App B. Requests to example.com for any path will always go to App C, since it is installed at the root path. Requests to test.mydomain.com:/test/* will go to App D. Requests to test.mydomain.com:/test2/* will go to App E. Requests to test.mydomain.com for any path other than /test or /test2 will fail with a 404. Creating Applications #When an app is being created, a path and an optional domain need to be specified. For the above example scenario:\nNo new apps can be created for example.com domain, since App C is installed at the root path. For the test.mydomain.con domain, no new app can be created under /test and /test2, other paths are available. For the default domain, /utils/appA and /appB are taken, other paths are available. New apps can be created under any path, including root path, for new domains and subdomains, like test.example.com. Notes # The domain specified for the app is used only for routing requests. The user has to ensure that the actual DNS routing is done properly outside of Clace for the API calls to land on the Clace server. Using wildcard DNS entries will reduce the configuration required in the DNS service. So if *.example.com points to the IP address of the Clace service, any domain based routing done in Clace will work with no further DNS configuration being required. The automated certificates created by Clace will be domain level certificates, wildcard certificates are not currently created. /_clace/ API path at the root level and /_clace_app/ within an app path are reserved paths, they are used by the Clace internal APIs, requests will not reach the app. This applies for all domains. _cl_ is reserved for use for internal apps, so app path last component cannot have _cl_. ","date":null,"permalink":"/docs/applications/routing/","section":"Docs","summary":"Details about request routing across Clace applications using path and domain","title":"Application Routing"},{"content":"Clace Server #The Clace server picks up its configuration from the config file specified at startup.\n$ clace server start -h NAME: clace server start - Start the clace server USAGE: clace server start [command options] [arguments...] OPTIONS: --server-uri value, -s value The server connection uri (default: \u0026#34;$CL_HOME/run/clace.sock\u0026#34;) [$CL_SERVER_URI] --admin-user value, -u value The admin user name (default: \u0026#34;admin\u0026#34;) [$CL_ADMIN_USER] --http.host value, -i value The interface to bind on for HTTP (default: \u0026#34;127.0.0.1\u0026#34;) [$CL_HTTP_HOST] --http.port value, -p value The port to listen on for HTTP (default: 25222) [$CL_HTTP_PORT] --https.host value The interface to bind on for HTTPS (default: \u0026#34;0.0.0.0\u0026#34;) [$CL_HTTPS_HOST] --https.port value The port to listen on for HTTPS (default: 25223) [$CL_HTTPS_PORT] --logging.level value, -l value The logging level to use (default: \u0026#34;INFO\u0026#34;) [$CL_LOGGING_LEVEL] --logging.console, -c Enable console logging (default: false) [$CL_LOGGING_CONSOLE] --help, -h show help GLOBAL OPTIONS: --config-file value, -c value TOML configuration file [$CL_CONFIG_FILE] --help, -h show help All the parameters have default values, specified in the code at clace.default.toml.\nA user-specified config file is required. The location of this file can be set using the command line arg --config_file. If CLI arg is not specified, the environment variable CL_CONFIG_FILE is used to locate the config file. There is no default location for this file, if no CLI argument and env value are specified, then no configuration file is loaded.\nAll arguments are read from the user specified configuration file. Some arguments are further configurable in the CLI or env. For example, set --http.host=7777 or env CL_HTTP_PORT to set the http port. The precedence order, from highest priority to lowest is:\nCLI argument ENV variable User specified config Default config in the source code for the Clace build version Home Directory #The CL_HOME environment variable is used to locate the home directory for the Clace server. If no value is set, this defaults to the directory from which the Clace server was started. This location is used to store:\nThe sqlite database containing the metadata information, default is $CL_HOME/clace.db The logs for the service, under the logs folder. The config folder contains the certificates to be use for TLS. The run folder contains app specific temporary files. Clace Client CLI #By default, the Clace client uses Unix domain sockets to connect to the Clace server. The $CL_HOME should point to the same location for server and client. If no changes are done for the server defaults, then the client can connect to the server locally without any other configuration being required. See here for details about the client configuration.\n","date":null,"permalink":"/docs/configuration/overview/","section":"Docs","summary":"Overview of Clace configuration, at the server level and client level and the $CL_HOME location for files","title":"Config Overview"},{"content":"Install Release Build #To install the latest release build on Linux, OSX or Windows with WSL, run the install script. Note down the password printed. Add the env variables as prompted and then start the service.\ncurl -L https://clace.io/install.sh | sh source $HOME/clhome/bin/clace.env clace server start \u0026amp; clace app create --approve /disk_usage github.com/claceio/clace/examples/disk_usage/ The app is installed under $HOME/clhome by default. The disk usage app should be available at https://127.0.0.1:25223/disk_usage after allowing the self-signed certificate. admin is the username and use the password printed by the install script.\nOn Windows, to install the Clace application, run\npwsh -Command \u0026#34;iwr https://clace.io/install.ps1 -useb | iex\u0026#34; Use powershell if pwsh in not available. The app is installed under $HOME\\clhome by default. Note down the generated password for the admin user. Open a new command window (to get the updated ENV values) and run\nclace server start to start the server. In another window, apps can be installed using same command as Linux/OSX. To install a bookmark manager app, run\nclace app create --approve /book github.com/claceio/apps/utils/bookmarks/ The bookmark manager app should be available at https://127.0.0.1:25223/book.\nSee start the service for details.\nInstall from Source #To install from source\nEnsure that a recent version of Go is available, version 1.21.0 or newer. Checkout the Clace repo. The below instructions assume you are using $HOME/clhome/clace.toml as the config file and $HOME/clhome as the work directory location. First add the below env variables to your shell .profile or .bash_profile:\nexport CL_HOME=$HOME/clhome export CL_CONFIG_FILE=$CL_HOME/clace.toml export PATH=$CL_HOME/bin/:$PATH Source the update profile file, like source ~/.bash_profile. Build the Clace binary\n# Ensure go is in the $PATH mkdir -p $CL_HOME/bin mkdir $HOME/clace_source \u0026amp;\u0026amp; cd $HOME/clace_source git clone -b main https://github.com/claceio/clace \u0026amp;\u0026amp; cd clace go build -o $CL_HOME/bin/clace ./cmd/clace/ Initial Configuration #To use the clace service, you need an initial config file with the service password and a work directory. Create the clace.toml file, and create a randomly generate password for the admin user account\nclace password \u0026gt; $CL_HOME/clace.toml This will print a random password on the screen, note that down as the password to use for accessing the applications.\nStart the service #To start the Clace server, run\nclace server start The service logs will be going to $CL_HOME/logs. To get the logs on the console also, you can add -c -l DEBUG to the server start command. The service will be started on https://localhost:25223 by default.\nLoad an App #To create an app, run the Clace client\nclace app create --dev /disk_usage $HOME/clace_source/clace/examples/disk_usage/ To audit and approve the app\u0026rsquo;s security policies, run\nclace app approve /disk_usage This will create an app at /disk_usage with the example disk_usage app. The disk_usage app provides a web interface for the du command, allowing the user to explore the subfolders which are consuming most disk space.\nTo access the app, go to https://127.0.0.1:25223/disk_usage. Use admin as the username and use the password previously generated. Allow the browser to connect to the self-signed certificate page. Or connect to http://127.0.0.1:25222/disk_usage to avoid the certificate related warning.\nThe code for the disk usage app is in GitHub. app.star is the starlark config and app.go.html is the html template. The other files are generated files and are created by Clace during app development.\n","date":null,"permalink":"/docs/installation/","section":"Docs","summary":"How to install Clace and do initial setup","title":"Installation"},{"content":"The page lists the available plugins and their API details.\nDatabase Storage #The store.in plugin supports a document store interface for writing data to SQLite (PostgreSQL support is coming soon). See store for details.\nHTTP Plugin #The http.in plugin supports making HTTP API calls. The APIs available are:\nAPI Type Notes get Read HTTP Get request head Read HTTP Head request options Read HTTP Options request post Write HTTP Post request put Write HTTP Put request delete Write HTTP Delete request patch Write HTTP Patch request All the API\u0026rsquo;s support the following parameters:\nurl (string, required) : the url to send the request to params (dict, optional) : url params to send headers (dict, optional) : HTTP headers to send body (string, optional) : body to send form_body (dict, optional) : form body to send form_encoding (string, optional) : the form encoding to use, application/x-www-form-urlencoded (default) or multipart/form-data json_body (object, optional) : the object to send as json encoded body auth (tuple(string, string), optional): HTTP basic auth username and password The response for all API\u0026rsquo;s (value within plugin_response) contains following properties:\nurl (string): the url the response is for status_code (int): the HTTP status code headers (dict): the output headers encoding (string): the transfer encoding header body (string) : the response body as a string json (object) : the response body un-marshalled as a json If the API calls fails to go through then the plugin response error property will be set. If the APi goes through, then the response error will not be set, even if API call fails with an HTPP error. The status_code will indicate whether the API succeeded on the server. To handle all possible error conditions, do (change to handle all 2xx codes if required)\nret = http.get(\u0026#34;http://localhost:9999/test\u0026#34;) if ret.error or ret.value.status_code != 200: return # error handling val = ret.value.json() # success handling Exec Plugin #The exec.in plugin allows running external commands, starting a new process for the specified command. The APIs available are:\nAPI Type Notes run Read/Write Runs the command as a new process The API supports the following parameters:\npath (string, required) : the command to run args (list of strings, optional) : arguments to pass to the cmd env (list of strings, optional) : the env to pass to the cmd, in the form key=value process_partial (bool, optional) : whether to process the output when there is a failure The response for the API (value within plugin_response) is of type list of strings. The stdout is scanned and split on newlines. The list of lines is returned. For example\nret = exec.run(\u0026#34;ls\u0026#34;, [\u0026#34;-l\u0026#34;, \u0026#34;/\u0026#34;], process_partial=True) if ret.error: return {\u0026#34;Error\u0026#34;: ret.error} for line in ret.value: # Process lines Note: Only first 100MB of the command stdout output is scanned currently, the rest is discarded. FS Plugin #The fs.in allows working with local file system. The APIs available are\nAPI Type Notes abs Read Returns the absolute path for given relative path list Read List files in specified directory find Read Find files under specified directory matching criteria The abs API supports the following parameter:\npath (string, required) : the file path The response for the API (value within plugin_response) is of type string, the absolute path for given path.\nThe list API supports the following parameters:\npath (string, required) : the directory path recursive_size (bool, optional, default false) : whether to include the recursive size of sub-directories ignore_errors (bool, optional, default false) : whether to ignore errors when accessing entries The response for the API is a list of type FileInfo. The FileInfo struct contains the fields:\nname (string) : the file name size (int) : the file size in bytes, rounded up to 4K is_dir (bool) : is it a directory mode (int) : file mode info The find API supports the following parameters:\npath (string, required) : the directory path name (string, optional) : the file name glob pattern to match limit (int, optional, default 10K, max 100K) : the limit on number of entries to return min_size (int, optional) : the minimum file size in bytes to look for ignore_errors (bool, optional, default false) : whether to ignore errors when accessing entries The response for the find API is a list of type FileInfo, same as returned by list.\n","date":null,"permalink":"/docs/plugins/details/","section":"Docs","summary":"Details of Clace Plugins","title":"Plugin Details"},{"content":"Application Types #A Clace application can be one of four types:\nDevelopment Apps : Used for developing apps, supports live reload from code change on disk. Production Apps : For production use. Can be created from git hosted source or from sources on local disk. Staging Apps : For reviewing code and config changes before they are pushed to prod. Every prod app has one staging app. Preview Apps : For creating a review environment for code changes, useful as part of code review. Development Apps #Development mode apps are used for developing or updating Clace apps. The source for these apps has to be on local disk, it cannot be git. Any code or config changes are live reloaded immediately for dev apps. To create a dev mode app, add the --dev option to the app create command. For example,\nclace app create --dev --approve /myapp /home/user/mycode Production Apps #Without the --dev options, apps are created as production apps by default. Production apps can be created from source on GitHub or from local disk. In either case, the source code for the app is uploaded to the Clace metadata database. For example:\nclace app create --approve example.com:/ /home/user/mycode creates an production app. After app creation, the original source location is not read, until a app reload operation is done to update the sources. The source folder /home/user/mycode can be deleted if reload is not required, since the sources are present in the Clace metadata database. Every production app automatically has one staging app associated with it.\nStaging Apps #Staging apps are created for each production app. The purpose of staging app is to be able to verify config and code changes before they are made live in the prod app. For example, after the previous app create command, a call to app list with the --internal option will show two apps:\nclace app list --internal Id Type Version GitCommit GitBranch Domain:Path SourceUrl app_prd_2aMvX3fc9fH18n6i2Jew0tNxnky PROD 1 example.com:/ /home/user/mycode app_stg_2aMvX3fc9fH18n6i2Jew0tNxnky STG 1 example.com:/_cl_stage /home/user/mycode The second app is the staging app for the first. app list shows only the main apps by default, the --internal option makes it show the linked apps.\nThe staging app url is available by suffixing _cl_stage at the end of the app path. So for an app at https://example.com/, the staging url is https://example.com/cl_stage. For an app at https://example.com/utils/app1, the staging app url is https://example.com/utils/app1_cl_stage.\nPromoting Changes #When there are code changes, running app reload will update the staging environment.\nclace app reload example.com:/ Reloaded apps: example.com:/_cl_stage 1 app(s) reloaded, 0 app(s) approved, 0 app(s) promoted. The staging app is version 2 now, prod app is still at version 1.\nclace app list -i Id Type Version GitCommit GitBranch Domain:Path SourceUrl app_prd_2aMvX3fc9fH18n6i2Jew0tNxnky PROD 1 example.com:/ /home/user/mycode app_stg_2aMvX3fc9fH18n6i2Jew0tNxnky STG 2 example.com:/_cl_stage /home/user/mycode At this point, going to the url example.com:/_cl_stage will show the updated code while example.com:/ has not been updated. To promote the changes to prod, run app promote\nclace app promote example.com:/ Promoting example.com:/ 1 app(s) promoted. The prod app is at the same version as the staging app now\nclace app list -i Id Type Version GitCommit GitBranch Domain:Path SourceUrl app_prd_2aMvX3fc9fH18n6i2Jew0tNxnky PROD 2 example.com:/ /home/user/mycode app_stg_2aMvX3fc9fH18n6i2Jew0tNxnky STG 2 example.com:/_cl_stage /home/user/mycode If the application code change requires new permissions, the reload operation will fail unless --approve is added.\nTo do the reload, approval and promotion is one step, do clace app reload --approve --promote example.com:/.\nGitHub Reload #The rules for fetching source code from local disk and GitHub are:\nIf the source url starts with http://, https:// or github.com, the source is assumed to be from a github API endpoint. Otherwise the source is assumed to be local disk on the Clace server. If Clace client and server are on different machines and local disk is being used, the code needs to be copied to the server node first. For GitHub source, the format is https://domain_name/org_name/repo_name/sub/folder, like github.com/claceio/clace/examples/disk_usage. The sub_folder should contain the app.star config file. During app create and app reload, the commit id takes precedence over the branch name if both are specified. During app reload, if no branch and commit are specified, the newest code is checked out from the current branch. main is used as current branch if no branch was previously specified for the app. Preview Apps #Preview allows the creation of any number of linked preview apps for a main app. This is supported for apps created from GitHub source. The commit id to use needs to be specified when creating the preview. For example,\nclace preview create /myapp 49182d4ca1cacbd8e3463a77c2174a6da1fb66c9 creates an app accessible at /myapp_cl_preview_49182d4ca1cacbd8e3463a77c2174a6da1fb66c9 which runs the app code in the specified commit id.\nPreview apps cannot be changed once they are created. If preview app requires new permissions, add the --approve option to the preview create command.\nWrite Mode Access #Staging and Preview apps have read only access by default to plugin APIs. This means that when they make calls to plugin APIs, only APIs defined as READ by the plugin are permitted. The HTTP plugin defines GET/OPTIONS/HEAD requests as READ type, POST/PUT/DELETE are defined as WRITE. For the CLI Exec plugin, the run API is defined as WRITE since the CLI command run might do write operations.\nFor cases where the plugin defines an API as Write, the app permission can overwrite the default type and define the operation to be a READ operation. For example, the disk_usage app runs the du command, which is a read operation. The app config defines the run plugin call as type=\u0026quot;READ\u0026quot;, over-riding the default WRITE type defined in the plugin. If no type is specified in the permission, the type defined in the plugin takes effect.\nStaging and Preview apps are allowed only READ calls by default, even if the app permissions allow WRITE operations. To allow stage apps access to WRITE operations, run clace app update stage-write-access all true. Change all to the desired app glob pattern.\nTo allow preview apps access to WRITE operation, run clace app update preview-write-access example.com:/ true. This changes the existing preview apps and any new preview apps created for example.com:/ to allow write operations, if the permissions have been approved.\n","date":null,"permalink":"/docs/applications/lifecycle/","section":"Docs","summary":"Lifecycle for Clace applications, pushing changes live safely","title":"Application Lifecycle"},{"content":"The request routing layer in Clace is built on top of the chi routing library. The routing is built for hypermedia exchange, so all routes are defined in terms of pages and fragments within the pages. This grouping of requests helps make it clear which API does what and provide an easy mechanism to deal with partial HTMX driven requests and full page refreshes. Simpler application might have one page with some interactions within that. Larger applications can be composed of multiple pages, each page having some interactive fragments.\nPages #The app contains an pages array, which defines all the routes for the app. For example, the app definition\napp = ace.app(\u0026#34;hello1\u0026#34;, pages = [ ace.page(\u0026#34;/\u0026#34;), ace.page(\u0026#34;/help\u0026#34;, \u0026#34;help.go.html\u0026#34;) ] ) defines two routes. / routes to the default index page, /help routes to the help page.\nPage #ace.page is used to define the properties for a single page. The parameters for ace.page are:\nProperty Optional Type Default Notes path False string The route, should start with a / full True string index.go.html if custom layout, else index_gen.go.html The template to use for full page requests partial True string None The template to use for partial page requests handler True function handler (if defined) The handler function to use for the route fragments True ace.fragment[] [] The fragment array method True string GET The HTTP method type: GET,POST,PUT,DELETE etc type True string html The response type, html or json Fragment #The fragments array in the page definition defines the API interactions within the page. The parameters for ace.Fragment are:\nProperty Optional Type Default Notes path False string The route, should not start with a / partial True string Inherited from page The template to use for partial requests handler True function Inherited from page The handler function to use for the route method True function GET The HTTP method type: GET,POST,PUT,DELETE etc type True string html The response type, html or json Note: partial and handler are inherited from the page level, unless overridden for the fragment. For example, in this page definition\nace.page(\u0026#34;/game/{game_id}\u0026#34;, full=\u0026#34;game.go.html\u0026#34;, partial=\u0026#34;game_info_tmpl\u0026#34;, handler=game_handler, fragments=[ ace.fragment( \u0026#34;submit\u0026#34;, method=ace.POST, handler=lambda req: post_game_update(req, \u0026#34;submit\u0026#34;)), ace.fragment( \u0026#34;refresh\u0026#34;, partial=\u0026#34;refresh_tmpl\u0026#34;) ] ) there are three API\u0026rsquo;s defined:\nGET /game/{game_id} : game_handler is the handler function, full page request returns game.go.html, partial HTMX request returns game_info_tmpl template. POST /game/{game_id}/submit : The handler is a lambda function. The game_info_tmpl template partial is inherited from the page as the response for the POST. GET /game/{game_id}/refresh : game_handler is inherited from the page. For full page, it returns the game.go.html response. For partial HTMX requests, refresh_tmpl template is returned. API Flow #The API flow is\nThe API is first sent to the matching app Within the app, the API is routed based on the routes defined If there is a handler defined for the matched route, the handler function is called with the request as argument The response template is invoked, with an input map containing a Data property as returned by the handler function If the API type is set to json, the handler response is directly returned, with no template being used If automatic error handling is enabled (error_handler is defined), then the error handler function is called if there is a error during the handler invocation. The error handler does the response processing, the templates defined in the route are not used. Notes # For HTMX requests, the partial template is used. For regular requests, the page level full template is used If there is a function called handler defined, that is the default handler function for all API\u0026rsquo;s For non-HTMX update requests (POST/PUT/DELETE), the Post-Redirect-Get pattern is automatically implemented by redirecting to the location pointed to by the Referer header. ","date":null,"permalink":"/docs/app/routing/","section":"Docs","summary":"Defining API routes, handling pages and fragments","title":"Request Routing"},{"content":"Most configuration options specified in the following sections are for the Clace server. The Clace client CLI, which talks with the Clace server using unix domain sockets, uses a small subset of the config properties. If the Clace client runs on the same machine as the server, then the same config file can be used for both. See here for details.\n","date":null,"permalink":"/docs/configuration/","section":"Docs","summary":"Configuration options for the Clace server and client.","title":"Configuration"},{"content":"","date":null,"permalink":"/docs/applications/","section":"Docs","summary":"Application routing and security details","title":"Managing Applications"},{"content":"HTTP #For HTTP requests, by default the Clace service listens on port 25222, on the localhost(127.0.0.1) interface. This means the HTTP port can be accessed from the same machine, it cannot be accessed remotely. To configure this, update the config file\n[http] host = \u0026#34;127.0.0.1\u0026#34; # bind to localhost by default for HTTP port = 25222 # default port for HTTP to desired values. Port 0 means bind to any available port. Port -1 means disable HTTP access. Use host as 0.0.0.0 to bind to all available interfaces.\nHTTPS #For HTTPS requests, the Clace service listens on port 25223 by default, on the any(0.0.0.0) interface. This means the HTTPS port can be accessed from the same machine and also remotely. The various HTTPS config settings are:\n# HTTPS port binding related Config [https] host = \u0026#34;0.0.0.0\u0026#34; # bind to all interfaces (if port is \u0026gt;= 0) port = 25223 # port for HTTPS enable_cert_lookup = true # enable looking for domain specific certificate files on disk service_email = \u0026#34;\u0026#34; # email address for registering with Let\u0026#39;s Encrypt. Set a value to enable automatic certs use_staging = true # use Let\u0026#39;s Encrypt staging server cert_location = \u0026#34;$CL_HOME/config/certificates\u0026#34; # where to look for existing certificate files storage_location = \u0026#34;$CL_HOME/run/certmagic\u0026#34; # where to cache dynamically created certificates Port 0 means bind to any available port. Port -1 means disable HTTPS access.\nUsing the HTTPS port is recommended even for the local environment. HTTP/2 works with HTTPS only. Server Sent Events (SSE) are used by Clace for live reload of dev apps, SSE works best with HTTP/2. Without HTTP/2, there can be connection limit issues with HTTP causing connections from browser to Clace server to hang. TLS Certificates #In the default configuration, where service_email is empty, certmagic integration is disabled. The certificate handling behavior is:\n$CL_HOME/config/certificates is looked up for a crt and key file in the PEM format matching the domain name as passed to the server. If a matching certificate is found, that is used. If no domain specific certificate is found, then the default certificate default.crt and default.key are looked up. If found, that is used. If default certificate is not found, then a self-signed default certificate is auto created in the certificates folder. The intent is to allow custom certificates to be placed in the certificate folder, which will be used. If not found, a self-signed certificate is created and used. For example, if files example.com.crt and example.com.key are found in the certificates folder, those are used for example.com domain.\nDev Env Certificates #For local dev environment, using the auto generated certs will result in browser warnings when connecting to the HTTPS port. To avoid this, use a tool like mkcert to generate root CA for local env. Install mkcert and then run\nmkcert -install mkcert example.com \u0026#34;*.example.com\u0026#34; example.test localhost 127.0.0.1 ::1 cp ./example.com+5.pem $CL_HOME/config/certificates/default.crt cp ./example.com+5-key.pem $CL_HOME/config/certificates/default.key The mkcert generated certificates signed with the local CA will be used after the next Clace server restart.\nFor local env, wildcard DNS will not work without tools like dnsmasq. An easier alternative is to add /etc/hosts entries as required mapping to 127.0.0.1. Using url path routing instead of domain based routing for local env is a convenient option.\nEnable Automatic Signed Certificate #Clace uses the certmagic library for fully-managed TLS certificate issuance and renewal for production deployment. Certmagic is disabled by default. To enable, the pre-requisites are:\nThe https config is using 443 as the port number. Running on privileged ports requires additional setup There is an DNS entry created pointing your host name or domain wildcard to the IP address of the host running the Clace server. This has to be done in your DNS provider config. Port 443 is reachable from the public internet. This has to be done in your infrastructure provider network settings. Once the pre-requisites are met, set the service_email config parameter to your email address. This enables certmagic based certificate creation. The config will look like:\n# HTTPS port binding related Config [https] host = \u0026#34;0.0.0.0\u0026#34; port = 443 enable_cert_lookup = true # enable looking for domain specific certificate files on disk service_email = \u0026#34;MY_EMAIL@example.com\u0026#34; # CHANGE to your email address use_staging = true # CHANGE to false for production cert_location = \u0026#34;$CL_HOME/config/certificates\u0026#34; storage_location = \u0026#34;$CL_HOME/run/certmagic\u0026#34; Test out the certificate creation by sending HTTPS requests to port 443. If the certificate is getting created, change use_staging to false. Let\u0026rsquo;s Encrypt has strict rate limits, use the staging config to ensure that the pre-requisites are met before using the production config.\nWith this config, certmagic is used to create certificates for all HTTPS requests. Self signed certificates and enable_cert_lookup property are not used when certmagic is enabled.\nPrivileged Ports #On Linux, binding to low ports is disabled for non-root users. To enable binding to port 80 for HTTP and 443 for HTTPS, run the command\nsudo setcap cap_net_bind_service=+ep /path/to/clace_binary This would be required after any new build or update of the Clace binary.\nNotes # Please provide a valid email address in service_email. This allows you to receive expiration emails and also allows the CA to contact you if required. Start the configuration with staging use_staging = true, change to production config use_staging = false after ensuring that DNS and networking is working fine. If port 0 is used, the service will bind to any available port. Look at the stdout or logs to find the port used. Clients would have to be updated after every server restarted to point to the new port. Only the TLS-ALPN challenge is enabled in Clace. The HTTP and DNS based challenges are not supported currently. If Clace is running behind a load balancer, ensure that the load balancer is doing TLS pass-through. If TLS termination is done in the load balancer, then the automatic certificate management done by Clace through certmagic will not work. ","date":null,"permalink":"/docs/configuration/networking/","section":"Docs","summary":"Clace uses unix domain sockets for client CLI requests. HTTP and HTTPS are used for application requests. Automatic signed certificate creation is supported for HTTPS.","title":"Ports and Certificates"},{"content":"The store.in plugin provides a document store interface to work with SQLite tables (PostgreSQL support is coming soon). The goal for the store plugin is to support a full managed interface, creating the app automatically creates the tables required for the app.\nIntroduction #The store.in plugins automatically creates tables with the specified schema. The tables are created on first load unless they are already present. The tables are linked to the app. The tables use a document store interface. The data is stored as JSON(B) data types. To query the data, a structured interface is used similar to the one provided by MongoDB. The advantage of this approach is that SQL injection is not possible, even if the application code is incorrectly written.\nSchema Definition #The schema for the app is specified in the schema.star file in the root directory of the app code. The format of this file is like:\ntype(\u0026#34;bookmark\u0026#34;, fields=[ field(\u0026#34;url\u0026#34;, STRING), field(\u0026#34;tags\u0026#34;, LIST), ], indexes=[ index([\u0026#34;url\u0026#34;], unique=True) ]) type(\u0026#34;tag\u0026#34;, fields=[ field(\u0026#34;tag\u0026#34;, STRING), field(\u0026#34;urls\u0026#34;, LIST), ], indexes=[ index([\u0026#34;tag\u0026#34;], unique=True) ]) Multiple types can be specified. Each type has a name, list of fields and list of indexes. Each field has a name and a type, the valid types are INT, STRING, BOOLEAN, LIST and DICT.\nEach type maps to one table in the underlying database. Indexes can be created on the fields. Each index is specified as list of field names. Adding :desc to the field name changes the index to be sorted descending instead of default ascending. Setting unique property to True makes it an unique index.\nSchema Design #SQL tables are used as underlying storage, but joins are not supported by the store.in interface. The schema design to use would be same as schema used for a document database. Since LIST and DICT data types are supported, de-normalized schema is recommended instead of normalized schema.\nStore Types #The type information is read from the schema file and schema types are automatically created for the app. The doc namespace has type objects for each type. For the previous example, the two types created are doc.bookmark and doc.tag. The table namespace also has entry populated which reference the table names for the type. For the previous example, the two table names available are table.bookmark and table.tag. This allows creating objects and persisting them using the store API by doing:\nbookmark = doc.bookmark( url=\u0026#34;http://clace.io\u0026#34;, tags=[\u0026#34;webapps\u0026#34;, \u0026#34;tools\u0026#34;]) ret = store.insert(table.bookmark, bookmark) Store APIs #The API\u0026rsquo;s in the store.in plugin and their arguments and response are:\nAPI Type Args Response Value Notes begin Read - - Begin a new transaction commit Write - - Commit active transaction rollback Read - - Rollback active transaction select_by_id Read table: string id : int doc Select one record by id select Read table: string filter : dict sort : list string offset : int limit : int (default 10,000) doc iterator Select by filter select_one Read table: string filter : dict doc Select one by filter count Read table: string filter : dict int Count entries by filter insert Write table: string entry : doc id : int Insert a document update Write table: string entry : doc count : int Update a document delete_by_id Write table: string id : int count : int Delete one document by id delete Write table: string filter : dict count : int Delete multiple docs by filter Transactions #The transaction handling APIs begin, commit and rollback take no arguments. All the other APIs take the table name as the first argument. The transaction created by the begin is saved in a thread local, there is no need to pass the transaction manually to subsequent API calls. The transaction rollback is automatically done at the end of the API handler if commit is not done explicitly.\nAutomatic Fields #All tables have some fields added automatically. These are:\nField Type Notes _id int Primary key _version int Schema version _created_by string User id _updated_by string User id _created_at timestamp _updated_at timestamp These fields can be accessed like regular user defined field in the store APIs. So bookmark._id can be used the way bookmark.url is used in all the APIs.\nIterators #The select API returns a document iterator. Use a regular python for loop to iterate on the entries. For example,\nret = store.select(table.bookmark, {}, limit=100, sort=[\u0026#34;_created_at:desc\u0026#34;]) if ret.error: return ace.response({\u0026#34;error\u0026#34;: ret.error}, \u0026#34;error\u0026#34;) bookmarks = [] for row in ret.value: bookmarks.append(row) Iterating till the end of the loop automatically closes the iterator. Returning from a handler without closing an iterator will cause the handler to fail. The iterator is automatically closed by the Clace platform to prevent a resource leak. The API failure is used to indicate to the developer that the code needs to be fixed to explicitly close the iterator.\nNote: The iterator cannot be directly returned from the handler. A list needs to be created and populated if the entries need to be passed to the template. Select Limits and Sort #For the select API, a limit of 10,000 is set as the default limit value. The API can pass a different limit value if required. The maximum value allowed for the limit is 100,000. Passing a limit beyond that will result in an API failure.\nThe sort argument can be used to sort the result for the select API. The argument is a list of strings. For example, [\u0026quot;age\u0026quot;, \u0026quot;city\u0026quot;] is sorted on age and city ascending. [\u0026quot;age\u0026quot;, \u0026quot;city:desc\u0026quot;] is sorted on age ascending and city descending.\nFilter #The select, select_one, count and delete APIs take a filter parameter. The filter has to be specified as a dict. The format of the filter is similar to the format used by MongoDB. The advantage of this over a SQL expression is that there is no possibility of SQL injection, even with an improperly written application.\nThe filter is specified as a list diction, the keys are the names of the field to apply the condition on. The value can be a value, in which case it is treated as a equality match. If the value is an diction, then the it is treated as a expression to apply on the specified field.\nFor example, a filter {\u0026quot;age\u0026quot;: 30} is equivalent to sql where clause age = ? with the parameter bound to 30. Filter {\u0026quot;age\u0026quot;: 30, \u0026quot;city\u0026quot;: \u0026quot;New York\u0026quot;, \u0026quot;state\u0026quot;: \u0026quot;California\u0026quot;} is same as sql age = ? AND city = ? AND state = ?, with the appropriate bindings. To express an or condition, do filter as {\u0026quot;age\u0026quot;: 30, \u0026quot;$or\u0026quot;: [{\u0026quot;city\u0026quot;: \u0026quot;New York\u0026quot;}, {\u0026quot;state\u0026quot;: \u0026quot;California\u0026quot;}]}. That translates to age = ? AND ( city = ? OR state = ? )\nTo express an inequality condition, do {\u0026quot;age\u0026quot;: {\u0026quot;$gt\u0026quot;: 30}} which becomes age \u0026gt; ?.\nThe logical operators supported are $AND and $OR, case insensitive.\nThe filter operators supported (case insensitive) are\nFilter SQL Notes $GT \u0026gt; $LT \u0026lt; $GTE \u0026gt;= $LTE \u0026lt;= $EQ = Default when value is not a dict $NE != $LIKE like Value has to be passed with % added, it is not added automatically. For example \u0026quot;%test%\u0026quot; ","date":null,"permalink":"/docs/plugins/store/","section":"Docs","summary":"Store plugin provides a document store interface for SQLite and Postgres","title":"Store Plugin"},{"content":"Request Structure #The handler function is passed one argument which has the details about the API call. The fields in this structure are:\nProperty Type Notes AppName string The app name in the config AppPath string The path where the app is installed. If root, then empty string AppUrl string The url for the app root PagePath string The path for the current page. If root, then empty string PageUrl string The url for the current page Method string The HTTP method, GET/POST etc IsDev bool Is the app installed in dev mode IsPartial bool Is this an HTMX driven partial request RemoteIP string The Client IP address UrlParams dict The url parameters, if used in the url spec Form dict The form data, including body and query Query dict The url query data, as a string array PostForm dict The form data from the body Data dict The response from the handler function Accessing Inputs #Url Parameters #For a route defined like\nace.page(\u0026#34;/user/{user_id}/settings\u0026#34;, \u0026#34;index.go.html\u0026#34;) the url parameter user_id can be accessed in the handler\ndef handler(req) user_id = req.UrlParams[\u0026#34;user_id\u0026#34;] Wildcard parameters are allowed at the end of the route. These are defined as\nace.page(\u0026#34;/path/*\u0026#34;, \u0026#34;index.go.html\u0026#34;) and can be accessed as\ndef handler(req) user_id = req.UrlParams[\u0026#34;*\u0026#34;] Regexes are also allowed in the path, these are defined as ace.page(\u0026quot;/articles/{aid:^[0-9]{5,6}}\u0026quot;) and accessed as req.UrlParams[\u0026quot;{aid}\u0026quot;]. The route will match only if the regex matches.\nQuery String Parameters #Query string parameters can be accessed as\ndef handler(req) name = req.Query.get(\u0026#34;name\u0026#34;) name = name[0] if name else None The value for Query is an string array, since there can be multiple query parameters with the same name.\nForm Data #Form data can be accessed like\ndef handler(req) name = req.Form.get(\u0026#34;name\u0026#34;) name = name[0] if name else None The value for Form is an string array, since there can be multiple form parameters with the same name.\n","date":null,"permalink":"/docs/app/request/","section":"Docs","summary":"The Request structure passed into the handler function, handling argument and post data","title":"Request"},{"content":"Clace applications run in a sandbox environment with no direct access to the system or Clace service. All access is through plugins. When an application is installed, the admin can audit the application for what access is being requested. Only the permissions which are approved are allowed at runtime.\nSecurity Model #The security model used by Clace is:\nThe application code written in Starlark(python) and HTML templates is untrusted. The Clace service and plugin code (in Go) are trusted. The admin can audit and approve the access required by the untrusted application code when the app is being installed. After installation, further application code updates do not require any further audit, as long as no new permissions are required. If the updated app code requires any new permission, the new plugin call will fail at runtime with a permission error. The trust boundary is about what the application can do in the backend. The frontend code is sandboxed by the browser, there is no additional auditing implemented for the frontend code.\nUsecases #This security model allows for the following:\nUsers can download applications and run on their machine, without worrying about what operations the app can do on their system outside the audited permissions. Operations teams can install and approve applications. Further application updates can be handled by the development team, without requiring the operational admins to verify the updated code. As long as the application works within the originally defined permission boundary, application updates will continue to work. Application developers can use LLM powered automated code generation tools without worrying about the side-effects of the code. If the generated code tries to perform any operation not previously approved, it will fail. Sample Application #As an example, the disk usage analysis app requires two permissions\napp = ace.app(\u0026#34;Disk Usage\u0026#34;, pages=[ace.page(\u0026#34;/\u0026#34;, partial=\u0026#34;du_table_block\u0026#34;)], permissions=[ ace.permission(\u0026#34;exec.in\u0026#34;, \u0026#34;run\u0026#34;, [\u0026#34;du\u0026#34;]), ace.permission(\u0026#34;exec.in\u0026#34;, \u0026#34;run\u0026#34;, [\u0026#34;readlink\u0026#34;]) ], style=ace.style(\u0026#34;https://unpkg.com/mvp.css@1.14.0/mvp.css\u0026#34;), ) It requests permission to use the exec.in plugin to run two CLI commands, first being du and other being readlink. When installing the app\n$ ./clace app create /utils/disk_usage ./examples/disk_usage/ App audit results /utils/disk_usage : app2WPQHwr5ZpKELqh0TvP5YMSnbab Plugins : exec.in Permissions: exec.in.run [du] exec.in.run [readlink] App created. Permissions need to be approved an audit report is shown with these requests. To approve the requested permissions, the admin can do\n$ ./clace app approve /utils/disk_usage App audit: /utils/disk_usage Plugins : exec.in Permissions: exec.in.run [du] exec.in.run [readlink] App permissions have been approved. The approval can be done during the app create itself, in that case the app is installed and approved immediately. None of the plugin code runs during the app creation, even for calls at the global scope. If the audit report does not match expectations, the app can be deleted.\n$ ./clace app create --approve /utils/disk_usage ./examples/disk_usage/ App audit results /utils/disk_usage : app2WPQpws6C1mWb6BujYGOdWMnF1C Plugins : exec.in Permissions: exec.in.run [du] exec.in.run [readlink] App created. Permissions have been approved $ ./clace app delete /utils/disk_usage App deleted /utils/disk_usage Once the app is created, if the application code is updated to change the line from\nret = exec.run(\u0026#34;readlink\u0026#34;, [\u0026#34;-f\u0026#34;, current], process_partial=True) to\nret = exec.run(\u0026#34;rm\u0026#34;, [\u0026#34;-f\u0026#34;, current], process_partial=True) The app will fail at runtime with an error like\napp /utils/disk_usage is not permitted to call exec.in.run with argument 0 having value \u0026#34;rm\u0026#34;, expected \u0026#34;readlink\u0026#34;. Update the app or audit and approve permissions The app cannot be run until either the code change is reverted or the admin approves the new call to rm.\nRoadmap #The following enhancements are planned for the security model\nSecrets management is planned, in such a manner that the application can request access to specific secrets. The application can use the secret but will not have direct access to the secret value, it will work with a reference to the secret key. ","date":null,"permalink":"/docs/applications/appsecurity/","section":"Docs","summary":"Application Security and sandboxing model for Clace","title":"Application Security"},{"content":"The default configuration for the Clace server is:\nApplication management (admin APIs) are accessible locally only, using unix domain sockets An admin user account is used to access applications The admin user password has to be added to the server config file, or a random password is generated every time the server is restarted Applications can be change not require any authentication There is no user management support in Clace currently, the plan is to integrate with OAuth2 providers and SAML services for managing user access Admin Account Password #When the Clace server is started, it looks for the entry\n[security] admin_password_bcrypt = \u0026#34;\u0026#34; # the password bcrypt value in the config file. If the value is undefined or empty, then a random password is generated and is used as the admin password for that server session. The password being used is displayed on the stdout of the server startup. This will change on every restart.\nTo configure a fixed value for the admin user password, use the password helper command:\nclace password to generate a random password. This will print out the password and its bcrypt value to the screen. Save the password in your password manager and add the bcrypt hash to your config file.\nTo use a particular value for the admin password, run:\nclace password --prompt This will prompt for the password and print out the bcrypt hash to add to the config file.\nAdmin API Access #By default, the Clace client uses Unix domain sockets to connect to the Clace server. Admin API calls to manage applications are disabled over HTTP/HTTPS by default. Unix sockets work when the client is on the same machine as the server, the client does not need to pass any credentials to connect over unix sockets. See here for details about the client configuration.\nTo enable remote API calls, where the client is on a different machine from the server, the server needs to be changed to add the following:\n[security] admin_over_tcp = true If running the Clace client from a remote machine, the config options required for the client are:\nserver_uri = \u0026#34;https://\u0026lt;SERVER_HOST\u0026gt;:25223\u0026#34; admin_user = \u0026#34;admin\u0026#34; [client] admin_password = \u0026#34;\u0026#34; # Change to actual password skip_cert_check = false # Change to true if using self-signed certs These can be specified in a client config file or can be set in the CLI command line. All other config entries are ignored by the Clace client. Note that to connect to a Clace server over HTTP remotely, the server needs to be bound to the all interface(0.0.0.0), see here.\nIf server_uri is set to the https endpoint and the Clace server is running with a self-signed certificate, set skip_cert_check = true in config or pass --skip-cert-check=true in client commands to disable the TLS certificate check.\nApplication Security #See appsecurity for details about the application level sandboxing.\nPrivate Repository Access #The app create and app reload commands can read public GitHub repositories. If the repository is private, to be able to access the repo, the ssh key needs to be specified. In the clace.toml config file, create an entry like:\n[git_auth.infoclace] key_file_path = \u0026#34;/Users/myuser/.ssh/infoclace_rsa\u0026#34; password = \u0026#34;\u0026#34; infoclace is the git auth key name, key_file_path points to the location of a private key file for a user with access to the repository. When running app create, add the --git-auth infoclace option. The private key specified will be used for accessing the repository. app reload command will automatically use the same key as specified during the create.\nTo change the git auth key for an app, run:\nclace app update git-auth /myapp newkey ","date":null,"permalink":"/docs/configuration/security/","section":"Docs","summary":"Clace Security related configuration","title":"Security"},{"content":"By default, apps are created with the system authentication type. The system auth uses admin as the username. The password is displayed on the screen during the initial setup of the Clace server config.\nApps can also be changed to have no authentication, making them publicly accessible. To change app to be un-authenticated, add --auth-type none to the app create command. After an app is created, the auth type can be changed by running app update auth-type /myapp none.\nDefault Authentication Type #Any app when created uses the default auth type configured for the server. system is the default. To change this, add\n[security] app_default_auth_type = \u0026#34;github_prod\u0026#34; assuming there is a github_prod oauth config.\nAny new app created will use this as the auth-type unless overridden in the app create call or using app update.\nOAuth Authentication #OAuth based authentication is supported for the following providers:\ngithub google digitalocean bitbucket amazon azuread microsoftonline gitlab auth0 okta oidc The configuration format for each is\n[auth.github_test] key = \u0026#34;abcdefgh\u0026#34; secret = \u0026#34;mysecret\u0026#34; Here, the auth config entry name is github_test. The entry name can be one of the supported providers, or a supported provider name followed by a _ and a qualifier. The provider name is case sensitive. So github, google, github_prod, google_my_org etc are valid config names. github-test and my_org_google are not valid.\nThe server clace.toml can have multiple auth configs defined. One of them can be set to be the default using app_default_auth_type config. Apps can be configured to use one of system or none or a valid auth config name as the auth-type. For example, app 1 can use system and app 2 can use github_test.\nCallback Url #To enable any Oath provider, the callback url domain has to be specified in the server config. Add\n[security] callback_url = \u0026#34;https://localhost:25223\u0026#34; in the clace.toml. In the OAuth account, for an entry github_test, the callback url to use will be https://localhost:25223/_clace/auth/github_test/callback.\nThe format for the callback url to use is \u0026lt;CALLBACK_URL\u0026gt;/_clace/auth/\u0026lt;PROVIDER_ENTRY_NAME\u0026gt;/callback. OAuth applications are strict, the callback url has to exactly match this format.\nOAuth Config Details #The config details depend on the provider type. The key is generally the Client Id and the secret is the Client Secret. For some providers, additional config config entries are supported. These are:\ngoogle: The google provider supports a hosted_domain option. This is the domain name to verify on the user being logged in. For example, this can be set to clace.io. okta: The Okta provider supports the org_url config, the tenant url to verify. auth0: The Auth0 provider supports the domain config. oidc: OIDC supports the discovery_url config property. For all the providers, an optional scopes property is also supported. This is the list of scopes to configure for the OAuth account.\nNote: The first time a new provider is added, it is important to manually verify an app, to verify if the required authentication restrictions are in place. For example, with google, any valid google user can login, including gmail.com accounts. The hosted_domain config has to be used to restrict this. The OAuth integration internally uses the goth library, see examples for a sample implementation.\n","date":null,"permalink":"/docs/configuration/authentication/","section":"Docs","summary":"Details about authentication mechanisms for app access, including OAuth based auth","title":"App Authentication"},{"content":"Response Data #The Response from the handler function is passed to the template to be converted to HTML. The handler response is accessible through .Data, or $Data if in another scope. Any python object can be used as the return value. Using a dictionary is recommended, so that error handling is easier. Adding a Error key in the response dict can indicate to the template that an error condition needs to be handled.\nFor example, a handler like\ndef handler(req): name = req.Query.get(\u0026#34;name\u0026#34;) if name: return {\u0026#34;Name\u0026#34;: name[0], \u0026#34;Error\u0026#34;: None} else: return {\u0026#34;Error\u0026#34;: \u0026#34;Name not specified\u0026#34;, \u0026#34;Name\u0026#34;: None} app = ace.app(\u0026#34;test\u0026#34;, pages = [ace.page(\u0026#34;/\u0026#34;)]) allows the template to handle the error by doing\n{{block \u0026#34;clace_body\u0026#34; .}} {{if .Data.Error}} \u0026lt;div style=\u0026#34;color: red\u0026#34;\u0026gt;{{.Data.Error}}\u0026lt;/div\u0026gt; {{else}} Hi {{.Data.Name}} {{end}} {{end}} Redirect Response #If the API needs to redirect the client to another location after a POST/PUT/DELETE operation, the handler function can return an ace.Redirect structure. The fields in this structure are:\nProperty Optional Type Default Notes url false string The url to redirect to code true int 303 The HTTP status code, 303 or 302 For example, this code does a 303 redirect after a POST API, which provides handling for update requests.\ndef create_game(req): level = req.Form[\u0026#34;level\u0026#34;] ret = http.post(SERVICE_URL + \u0026#34;/api/create_game/\u0026#34; + level[0]) return ace.redirect(req.AppPath + \u0026#34;/game/\u0026#34; + ret.json()[\u0026#34;GameId\u0026#34;]) Custom Response #In some cases, a custom response need to be generated, with special headers. Or the response needs to use a template different from the one defined in the route, which could happen in the case of an error. For such cases, a ace.Response structure can be returned by the handler. The fields in this structure are:\nProperty Optional Type Default Notes data false object The response data block true string Optional only if type is \u0026ldquo;json\u0026rdquo; type true string inherited from the route type definition If \u0026ldquo;json\u0026rdquo;, block is ignored code true int 200 HTTP status code retarget true string HX-Retarget header value, CSS selector to target, like \u0026ldquo;#error_id\u0026rdquo; reswap true string HX-Reswap, like \u0026ldquo;outerHTML\u0026rdquo; For example, this handler code uses retarget to handle errors by updating the html property which has id \u0026ldquo;gameErrorId\u0026rdquo;\nret = http.post(api_url).json() if ret.get(\u0026#34;Error\u0026#34;): return ace.response(ret, \u0026#34;game_error_block\u0026#34;, retarget=\u0026#34;#gameErrorId\u0026#34;) return fetch_game(req, game_id) This code returns a 404 with a custom body generated from a template block called \u0026ldquo;invalid_challenge_block\u0026rdquo;\nif challenge.get(\u0026#34;Error\u0026#34;): return ace.response(challenge, \u0026#34;invalid_challenge_block\u0026#34;, code=404) JSON Response #All responses are HTML by default, as required for building a proper Hypermedia client. There are some cases where data needs to be returned to the client in JSON format. The type property can be used for those cases. For example, this API returns JSON\nace.page(\u0026#34;/memory\u0026#34;, handler=memory_handler, type=ace.JSON), Here, the response from the handler function is returned as JSON, no template is used. Also, in this handler, if there is a call to ace.Response, the type will default to JSON since that is the type specified at the route level. Mime type detection based on the Accept header is planned, it is not currently supported.\n","date":null,"permalink":"/docs/app/response/","section":"Docs","summary":"The response from the handler function, custom response and redirects","title":"Response"},{"content":"","date":null,"permalink":"/docs/app/","section":"Docs","summary":"Developing Clace applications, managing API routes and HTML templates","title":"Developing Applications"},{"content":"","date":null,"permalink":"/docs/plugins/","section":"Docs","summary":"Overview of Clace plugins and how to use them","title":"Plugins"},{"content":"Clace uses Go HTML templates for returning data to the client. See here for an overview of the template syntax. Hugo docs are a good source for overview of using go templates.\nThe Sprig template library functions are included automatically. Two functions from Sprig which are excluded for security considerations are env and expandenv.\nTwo extra functions are added for handling static file paths.\nstatic function #This function takes a file name and returns the url for a file in the static folder with a sha256 hash included in the file name. This approach is based on the hashfs library. If the static folder contains a file file1 with the content file1data, then a call to static \u0026quot;file\u0026quot; will return /test/static/file1-ca9e40772ef9119c13100a8258bc38a665a0a1976bf81c96e69a353b6605f5a7, assuming the app is installed at /test.\nThe returned file name has a hash based on the file contents. The file server used by Clace will serve aggressive cache headers Cache-Control: public, max-age=31536000 when this file is referenced by the browser. When the file contents change, the content hash will change and the file name will change. The files on disk are not renamed, only the filesystem used by the Clace server in memory sees the hashed file names.\nThis approach allows for a build-less system with the aggressive static asset caching. The usual approach for this requires the static file to be renamed to have the hash value in the file name on disk. This require a build step to do the file renaming. The hashfs approach can avoid the build step. The file hash computation and compression are done once, during app installation in prod mode. There is no runtime penalty for this. In dev mode, the file hashing is done during the api serving.\nfileNonEmpty function #The fileNonEmpty function returns a bool, indicating whether a static file with that non-hashed name is present and is not empty. This can be used to conditionally include style files if present.\nFor example\n{{ if fileNonEmpty \u0026#34;css/style.css\u0026#34; }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ static \u0026#34;css/style.css\u0026#34; }}\u0026#34; /\u0026gt; {{ end }} checks if the \u0026ldquo;css/style.css\u0026rdquo; file is present and not empty. If so, it is linked using the static function, which returns a hashed file name which can be cached aggressively.\nNote: The path passed to static and fileNonEmpty functions should not include static, it is automatically added. So use {{ static \u0026quot;css/style.css\u0026quot; }}, not {{ static \u0026quot;static/css/style.css\u0026quot; }} Template File Location #Templates are loaded once on app initialization. In dev mode, they are automatically reload on file updates. By default, the app source home directory is searched for template files. This can be changed by adding this directive in the ace.app config.\nsettings={ \u0026#34;routing\u0026#34;: {\u0026#34;template_locations\u0026#34;: [\u0026#34;*.go.html\u0026#34;, \u0026#34;templates/*.go.html\u0026#34;]} } the default is [\u0026quot;*.go.html\u0026quot;]. If additional directories are added, \u0026quot;*.go.html\u0026quot; still needs to present in the list since generated files are created in the app home directory. Also, all folders in the list need to contains at least one template file. File names have to be unique across folders. Files are referenced by their name, without the folder name, when used in template import directives.\nStructured Template Layout #The default in Clace is to load all the templates in one parse operation. This is easy to get started with but can result in challenges when the same template block needs to be duplicated in different files. Clace also supports a structured template layout. See this blog for an explanation about the differences between the two layouts. The default in Clace is the WordPress layout, all template files are loaded in one go. To use the second, Django layout, use the structured format.\nIf there is a base_templates folder in the app main folder with one or more *.go.html files, the structured template layout is used. In the structured layout format, all the base template files are loaded in one parse operation. Each of the files in the app main folder is then individually loaded. Each top level file has access to its own template blocks plus the base templates.\nThis has the advantage that the main templates can have duplicate templates, with no conflicts because they are loaded individually. For example, if there is a base_templates/base.go.html file with\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; {{block \u0026#34;body\u0026#34; .}} {{end}} \u0026lt;footer\u0026gt;\u0026lt;/footer\u0026gt; \u0026lt;/html\u0026gt; {{end}} and a index.go.html file with\n{{define \u0026#34;body\u0026#34;}} My Index Body {{end}} {{- template \u0026#34;full\u0026#34; . -}} and a help.go.html file with\n{{define \u0026#34;body\u0026#34;}} My Help Body {{end}} {{- template \u0026#34;full\u0026#34; . -}} then a route using index.go.html will get the HTML for the index page and route using help.go.html with get HTML help page. Although the body is defined in two template files, there is no conflict since the root level template files are loaded independently.\nIf not using the structured template layout, if a duplicate block is found, the one to be used depends on the order in which files are loaded. To change the folder looked up for base template, set:\nsettings={ \u0026#34;routing\u0026#34;: {\u0026#34;base_template\u0026#34;: [\u0026#34;base_templates\u0026#34;, \u0026#34;template_helpers\u0026#34;]} } File Contents #When using custom layout, the app developer has to create the index.go.html file. Adding a directive like:\n{{ template \u0026#34;clace_gen_import\u0026#34; . }} in the head section ensures that the auto generated clace_gen_import directives are loaded. This will include the style files, HTMX library and the live reload functionality will be enabled in dev mode.\nIn Clace layout mode (the default), the auto generated index_gen.go.html file is used. The app developer has to provide a clace_body block. It can be in any file, the convention is to use app.go.html. For example:\n{{block \u0026#34;clace_body\u0026#34; .}} Data is {{.Data}} {{end}} The .Data binding has the response as returned by the handler function for the route.\n","date":null,"permalink":"/docs/app/templates/","section":"Docs","summary":"HTML templates functions, static file handling and customizations","title":"Templates"},{"content":"Clace supports working with Classless CSS libraries and also with TailwindCSS and DaisyUI. To use this, add the directive\nstyle=ace.style(\u0026#34;daisyui\u0026#34;) in the app definition. The fields in the ace.style structure are:\nProperty Optional Type Default Notes library false string The library to use, url to classless library, \u0026ldquo;tailwindcss\u0026rdquo; or \u0026ldquo;daisyui\u0026rdquo; themes true string[] [] The daisyui themes to include disable_watcher true bool false Whether to disable the tailwind watcher process startup in dev mode Classless CSS #If the library property is a url, it should point to a publicly accessible style file. The style file is downloaded into the static/gen/css/style.css file. The file is automatically included as part of the clace_gen_import template.\nFor example,\nstyle=ace.style(\u0026#34;https://unpkg.com/mvp.css@1.14.0/mvp.css\u0026#34;), imports the MVP.css library. Since this is classless, no changes are required in the HTML templates.\nTailwindCSS #To use TailwindCSS, in app settings, add\nstyle=ace.style(\u0026#34;tailwindcss\u0026#34;) Tailwind CSS works by scanning the HTML files for class names, generating the corresponding styles and then writing them to a static CSS file. A watcher process is started when an app using Tailwind is loaded in dev mode. The output of the watcher is written to static/gen/css/style.css file. This file is automatically included as part of the clace_gen_import template.\nTo ensure that the tailwind watcher is started, the tailwind CLI needs to be installed manually. The standalone CLI can be used. If using DaisyUI, use this custom build of the standalone CLI with DaisyUI included.\nThe Clace server config file has the following entries:\n[system] tailwindcss_command = \u0026#34;npx tailwindcss\u0026#34; file_watcher_debounce_millis = 300 tailwindcss_command is the command use to start the watcher. If the standalone version is being used change to\n[system] tailwindcss_command = \u0026#34;/path/to/tailwindcss\u0026#34; file_watcher_debounce_millis is used to prevent repeated reloads of the application files during dev mode. On slower machine, this value might have to be increased, but setting it too high will cause the reload to be slower.\nDaisyUI #To use DaisyUI, in app settings, add\nstyle=ace.style(\u0026#34;daisyui\u0026#34;, themes=[\u0026#34;dark\u0026#34;]) Change to the preferred theme. DaisyUI is a good option to use to get great default styling for components, with the full flexibility of Tailwind. To use DaisyUI, use the npm version of Tailwind or use this custom version of the standalone CLI with DaisyUI included. Clace takes care of creating the config files. Using the CDN version of DaisyUI or Tailwind is not recommended since that will cause the style files to be large.\n","date":null,"permalink":"/docs/app/styling/","section":"Docs","summary":"CSS Styling, TailwindCSS, DaisyUI","title":"Styling"},{"content":"Clace supports importing JavaScript libraries as JavaScript Modules . To use this feature, add\nlibraries=[ace.library(\u0026#34;d3\u0026#34;, \u0026#34;7.8.5\u0026#34;)] in the app definition. The fields in the ace.library structure are:\nProperty Optional Type Default Notes name false string The name of the library to import version false string The version of the library args true string[] [] Arguments to pass to esbuild The args array uses the esbuild cli syntax. For example, passing args as [\u0026quot;--minify\u0026quot;] will enable minification for the imported module.\nTo directly download a library from a CDN to the static folder, add the url directly. For example,\nlibraries=[\u0026#34;https://unpkg.com/jquery@3.3.1/dist/jquery.min.js\u0026#34;] The HTMX library and its SSE extension are automatically downloaded.\nJavaScript Modules #JavaScript modules (also called ESM or ECMAScript Modules) are a way to import Javascript libraries dynamically, providing a unique namespace for all functions. Modules, once imported, can be used in the client code without requiring any build steps. See jvns.ca and simonwillison.net for notes about this approach. Clace tries to provide an easy interface to modules, converting npm packages to module format so that subsequent code changes do not require any build steps.\nWorkflow #The workflow when using modules in Clace for an app in dev mode is:\nIn you home directly, install nodejs Using npm, install package you want to use a modules. for example npm install d3 Add the ace.library entry in the app config. Clace will automatically run esbuild and import the package as a module into static/gen/esm Add an importmap in the head section of the html. Like here. \u0026lt;script type=\u0026#34;importmap\u0026#34;\u0026gt; { \u0026#34;imports\u0026#34;: { \u0026#34;d3\u0026#34;: \u0026#34;{{ static \u0026#34;gen/esm/d3-7.8.5.js\u0026#34;}}\u0026#34; } } \u0026lt;/script\u0026gt; Use the library as required in your client. Like here import * as d3 from \u0026#34;d3\u0026#34;; Creating the module is a one time step. The generated module can be checked into source code. On a new machine, to make code changes to the app, you do not need nodejs or npm to be installed.\nFor production deployment, no changes are required. Checkout the git repo containing the source code and create a Clace app. Clace will serve the static assets over HTTP/2 with content hash based caching. The assets are compressed for serving, there is no need usually for mimifying the modules.\nEsbuild Config #Clace includes esbuild, there is no need to install esbuild manually. The Clace server config has the entry\n[system] node_path = \u0026#34;\u0026#34; The node_path property is used by esbuild, these paths are searched for packages in addition to the node_modules directories in all parent directories. See esbuild docs for details. Paths should be separated with : on Unix and ; on Windows.\nIf you install the npm packages in your home directory, esbuild will pick up those without any additional configuration. Since each Clace project is importing the npm package as a module, you do not need to maintain separate node_modules for each Clace project.\nIf you do not want esbuild to create modules, set the node_path property in the server config to disable. You will have to manually download the module file into the static folder.\nNotes # The version number specified in the ace.library is used to create the file name under static/gen/esm. The actual package version depends on what was install using npm. Ensure that the same version is installed by npm as specified in the library config. Only the minify option for esbuild has been tested with Clace. Other options like chunking the files might not work currently. The JavaScript support is for running JS on the browser. There is no support for running JavaScript on the Clace server, the server runs only Go code and starlark applications. If an library url is specified, that is downloaded directly. There is no need for npm package in that case. ","date":null,"permalink":"/docs/app/javascript/","section":"Docs","summary":"JavaScript dependency handling, esbuild config","title":"JavaScript"},{"content":"","date":null,"permalink":"/blog/","section":"Clace Blog","summary":"","title":"Clace Blog"},{"content":"Clace: Platform for Easy Self-Hosted Web Applications #Clace is an open-source platform to enable easy development and deployment of self-hosted web applications. The goals for the Clace project are:\nEnable development and deployment of secure internal web applications. Simplify ongoing maintenance of such apps by removing build and dependency related issues. Updating an app after six months or six years should just work. Provide portable and flexible deployment options, allowing use on personal machine and also shared across teams. Use-cases #Clace is built to solve two different types of use-cases:\nCustom applications: With fully customizable UI, this would be similar to solutions like Retool. A low-code approach is used, with a focus on Hypermedia driven applications. Workflows: This would be similar to solutions like Rundeck. A way to automate internal applications, with a form based interface, with support for triggered and scheduled execution. One of the aims of Clace is to make it possible for everyone, especially backend engineers, to develop and use simple web interfaces. For use-cases where a CLI was developed previously, a Clace based UI could be built. The backend service could invoke the CLI command or directly call the internal API which need to be exposed. Development and use of simple web interfaces for all types of use-cases should be made easier with Clace.\nHow does it work? #Clace applications are configured in Starlark, which uses a subset of Python syntax. The API routes are defined to be Hypermedia first, using HTML templates to drive the UI interactions. Templates are written using Go HTML templates. HTMX is used for server interactions. The backend code runs in a security sandbox and every access to plugins need to be explicitly permitted. Application updates can be done with no build step required. Clace integrates with TailwindCSS/DaisyUI for styling and has esbuild built-in for ESM support.\nSecurity #The Starlark backend code for Clace runs in a sandbox, all external interactions need to go through plugins. The Clace platform implements a security sandbox at the plugin boundary. Applications define what operations they need to be able to perform. The platform enforces these permissions at runtime.\nThis security model enables the following:\nUsers can download applications and run on their machine, without worrying about what operations the app can do on their system outside the audited permissions. Operations teams can install and approve applications. Further application updates can be handled by the development team, without requiring the operational admins to verify the updated code. As long as the application works within the originally defined permission boundary, application updates will continue to work. Application developers can use LLM powered automated code generation tools without worrying about the side-effects of the code. If the generated code tries to perform any operation not previously approved, it will fail. The sandbox will ensure that the apps can do only authorized operations. This makes Clace an ideal target for LLM (like GPT) generated applications. The Clace platform will add the authentication/authorization, gitops based deployment and operational monitoring features on top of the generated app.\nCurrent Status #Clace is in a beta state currently. Custom application support is functional. Support for loading plugins dynamically is in progress. You can try out Clace (on OSX, Linux or Windows with WSL) by doing:\ncurl -L https://clace.io/install.sh | sh source $HOME/clhome/bin/clace.env clace server start \u0026amp; clace app create --approve /disk_usage github.com/claceio/clace/examples/disk_usage/ The app should be available at https://127.0.0.1:25223/disk_usage after allowing the self-signed certificate. admin is the username, use the password printed by the install script. See installation for details.\nFollow Along #You can keep in touch by these means:\nStar the repo at github.com/claceio/clace Sign up for Email updates Follow on Twitter Subscribe to the blog RSS feed Follow ClaceIO on LinkedIn Connect on Discord Use discussions feature in Github or raise issues to provide feedback.\n","date":"1 November 2023","permalink":"/blog/intro/","section":"Clace Blog","summary":"Introducing the Clace project: A Platform for Easy Self-Hosted Web Apps","title":"Introducing Clace"},{"content":"Goals #The goals Clace is being built to support are:\nEnable easy development and deployment of self-hosted web applications. Simplify ongoing maintenance of such apps by removing build and dependency related issues. Flexible deployment options, allowing use on personal machine and also shared across teams. App Development Features #The dev time features supported currently by Clace are:\nHypermedia driven backend API design, simplifying UI development. Live reload using SSE (Server Sent Events) with HTTP/2 for all application changes, backend and frontend. Automatic creation of ECMAScript modules using esbuild. Automatic download for JavaScript and CSS dependencies. Support for TailwindCSS and DaisyUI watcher integration. Template caching and automatic reload on changes. App Deployment Features #The deployment features supported currently by Clace are:\nBackend app code runs in a security sandbox, with allowlist based permissions. No build step, the development artifacts are ready for production use. Support for github integration, apps being directly deployed from github code. Database backed application file system, for atomic version updates and rollbacks. Zero downtime application updates. Support for OAuth authentication Support for application data persistance to sqlite with full database schema management. Scalable backend, all performance critical code is in Go, only application handler code is in Starlark. Support for domain based and path based routing at the app level. Virtual filesystem with content hash based file names backed by SQLite database, enabling aggressive static content caching. Brotli compression for static artifacts, HTTP early hints support for performance. Automatic SSL certificate creation based on certmagic. Staging mode for app updates, to verify whether code and config changes work on prod before making them live. Preview app creation support, for trying out code changes. Roadmap #Clace is early in its development. The feature roadmap for Clace is:\nAll plugins are internal (built into Clace binary) currently. The plan is to move to an external plugin model, plugins being loaded dynamically using go-plugin. SQLite is used as the metadata storage currently. Support for postgres and other systems is planned. Support for workflow jobs, which would have a form based interface with limited customizability, but with support for triggered and scheduled execution. UI interface for Clace admin operations. Record replay based automatic integration test creation. Record all responses at the plugin boundary and use that to replay integration test scenarios. Distributed agent model, where the Clace server does the initial routing but the actual application execution happens on remote worker nodes. ","date":null,"permalink":"/features/","section":"Clace","summary":"Features supported by Clace","title":"Features"},{"content":"What is Clace? #Clace is an open-source (Apache-2.0 Licensed) project building a platform to easily develop and deploy self-hosted web applications. Clace provides a web application server focused on securely running multiple applications on a single installation. Applications are full stack, with a backend which can talk to external endpoints, the frontend can be auto generated forms or fully customizable web applications.\nProject Goals #The goal of this project is to make it easy for individuals and teams to develop and manage lightweight full stack applications in a secure manner. Fully configurable and secure self-hosted web applications with minimal code is the goal. Easy integrations to enable SSO/SAML based authentication and authorization controls, audit logs and integration with secrets manager for managing credentials are goals.\nA single developer should be able to manage the full application lifecycle, frontend and backend development, test automation and production deployment. Deployments should support a gitops like approach, with automatic preview environment to verify changes before making them live. It should be easy, for the original developer or a new developer, to make application code changes - after six months or after six years.\nClace aims to provide a developer friendly development environment, while providing a performant and scalable deployment platform which is operationally simple to manage.\nTerminology # Internal applications: Web applications built or downloaded for use by an individual or teams. For users, this could be apps to manage their machine, like monitor disk usage across folders. For teams, apps could automate common operations like managing resource limits, provisioning accounts etc. Sandboxing: Sandboxing is a security mechanism to ensure that an application stays within the rules set by the admin. If an application is configured to perform GET requests, trying to do a POST request from the application will fail until the admin authorizes the application to perform POST requests. Sandboxing is different from containers/jails. Those allow you to control at the network layer. Sandboxing allow more fine grained controls at the application API layer. Sandboxing allows usecases like allow GET but not POST, allow access to one database table but not to others etc. What\u0026rsquo;s with the name #The name Clace is a play on Command Line Ace, since building an UI for command line applications was an initial target use-case. The name is pronounced like Place, with a C.\nWhy is there a need for such a platform? #There are tools like Rundeck and Jenkins which allow automating operational scripts. These have very limited UI customizability. At the other extreme, SaaS services like Retool which focus on internal tools development allow developing a customizable UI using no-code generators. These speed up the initial development experience to some extent but at the cost of operational complexity. Ongoing maintenance and updates for such low-code applications does not work well with general software development lifecycle best practices. Most such tools use a heavy-weight single page application (SPA) based UI model.\nClace aims for a middle ground, aiming for easy self-hosting and operational simplicity while allowing fully customizable lightweight hypermedia driven applications, with a focus on security.\nHow is Clace implemented? #The way Clace tries to achieve these goals are:\nSingle binary web application server (in golang), with a set of plugins built in (also in golang) which allow access to external endpoints. The server is statically configured using a TOML file. Applications are configured using Starlark, which is a subset of Python. Python is an ideal glue language, Starlark is used to configure the application backend logic Multiple applications can be dynamically installed, an embedded SQLite database is used to store application metadata (Postgres support is in the roadmap). Path based routing, each app identified by a unique path. Also, domain based routing, which allows multiple domains to point to the same Clace instance, with path based routing being done independently for each domain. Automatic TLS certificate management for each domain to simplify deployments. A sandboxing layer is implemented at the Starlark(python) to Golang boundary, allowing the implementation of security and access control policies. Go code is trusted, Starlark code is untrusted. The application UI is implemented using Go HTML templates, with HTMX for interactivity. Go templates support context aware templating which prevents encoding related security issues. They also work well with the HTML fragments required for HTMX. No need to install any additional components like Python or NodeJS/NPM. Integration with tailwindcss-cli is supported. esbuild (using the esbuild go library) is supported out of the box for importing ESM modules. Current Status #The development of Clace was started in April 2023. The current status as of Jan 2024 is:\nClient and server (in a single binary) for service management and configuration. Initial support for application development with Starlark based configuration. Go HTML template loading and caching for request processing. HTTP plugin for communicating with REST endpoints. exec plugin for running system commands. Built in admin account for local development. Auto-sync (file system watcher) and Auto-reload using SSE (automatic UI refresh) for speeding up the application development cycle. Admin functionality using unix domain sockets for security. Application sandboxing checks to ensure only audited operations are allowed. Staged deployment support, preview app creations support. App data persistence to sqlite with managed tables. The next steps are to finalize the application development interface, add support for loading eternal plugins, add support for SSO and RBAC etc.\nWho is behind this project? #The project was started by Ajay Kidave. Ajay\u0026rsquo;s background has been in database systems and enterprise integration tools. Clace was started to find ways to reduce the development and operational complexity in tooling for internal applications.\nWhat is the longer-term plan for Clace? #The current plan is to develop the open source project, with the aim of making Clace a great platform for managing internal applications. The service can currently scale up vertically, support for metadata storage in Postgres will be added which will enable horizontal scaling also.\nFor workload isolation and security reasons, some use cases might require a more distributed backend approach. An worker/agent mode is planned in the longer-term. This will mean the Clace server will not actually run the application code, the application code will run on distributed agents. Most regular use-cases should not require the agent mode; vertical and horizontal scaling should cover normal workloads. The core functionality of Clace, including SSO integration and all plugins, will remain Apache-2.0 licensed.\n","date":null,"permalink":"/about/","section":"Clace","summary":"FAQ about Clace","title":"About Clace"},{"content":" GitOps Workflow - Staged deployments, versioning and preview environments with no infra to manage No build step - Backend and frontend development with no build step, the source repo is the deployment artifact Hypermedia web apps - Fast and lightweight backend driven apps, minimal frontend complexity Go binary, Starlark config - Performance and stability of Go, easy Python like backend config with no dependencies Secure app sandboxing - Apps runs in security sandbox, apply app code updates confidently SQLite data persistence - Easy access to SQLite based app data persistence, with auto-schema management What is Clace? Clace is an Apache-2.0 licensed project building a platform to develop and deploy hypermedia driven web apps for internal tools. For running multiple web applications on a single machine, Clace provides functionality which usually requires stitching together multiple services: reverse proxy like nginx/caddy (for domain/path based routing, TLS certs, static file serving), application server like uwsgi/gunicorn with micro-framework like flask (for API handling) and deployment infrastructure like containers/VMs/k8s (for isolation across apps, versioning and staged deployments, gitops). For internal tools, Clace provides similar functionality in a single lightweight binary.\nWhat can it do? Clace can be used to easily develop and deploy hypermedia driven web applications which are secure and portable. Clace can run web apps for personal use and also host applications for access over the public internet. Clace can be used by teams to host internal applications. Clace supports building a hypermedia driven web interface for an existing API's, a backend-for-frontend type pattern. Developing a web UI for command line applications is another use-case. CRUD applications and applications which glue together backend APIs are good candidates for Clace apps. How does it work? Clace and its plugins are implemented in go. User applications are developed and configured in Starlark, which uses a python inspired syntax. Users of Clace write only Starlark and HTML templates. The backend code runs in a security sandbox and access to plugins need to be explicitly permitted. The API routes are defined to be Hypermedia first, using template partials to drive the UI interactions. HTMX is used for server interactions from the UI. There are no Python or Javascript dependencies to install, no containers to create, no yaml files to manage. Application updates are done with a gitops workflow, with no-build step. Staging and preview environments are available for apps. Clace integrates with TailwindCSS/DaisyUI for UI styling and has esbuild built-in for ESM support. Data persistence to sqlite is supported using a document store interface. Clace manages request routing and TLS certificates creation and renewal, so a separate web server is not required.\nInstallation To install, start the service and create an app on Linux or OSX, run: $ curl -L https://clace.io/install.sh | sh # Note down the generated password $ source $HOME/clhome/bin/clace.env $ clace server start \u0026 # Any new app can be installed by running $ clace app create --approve /disk_usage github.com/claceio/clace/examples/disk_usage/ To install Clace on Windows, run: $ pwsh -Command \"iwr https://clace.io/install.ps1 -useb | iex\" Use powershell if pwsh is not available. Start a new command window (to get the updated ENV values) and run:\n$ clace server start To install apps on Windows, use the same command as Linux/OSX. To install a bookmark manager app, run:\n$ clace app create --approve /book github.com/claceio/apps/utils/bookmarks The disk usage app is available at https://localhost:25223/disk_usage (use port 25222 for HTTP). admin is the username, use the password printed by the install script. The bookmark manager is available at https://localhost:25223/book.\nSee here for more details about installation. Samples See documentation for steps to create Clace apps. See examples and apps repo for sample applications. See here for an online demo showing some Clace apps. See quick start for details on getting started with Clace.\nSign up for email updates Subscribe ","date":null,"permalink":"/","section":"Clace","summary":"GitOps Workflow - Staged deployments, versioning and preview environments with no infra to manage No build step - Backend and frontend development with no build step, the source repo is the deployment artifact Hypermedia web apps - Fast and lightweight backend driven apps, minimal frontend complexity Go binary, Starlark config - Performance and stability of Go, easy Python like backend config with no dependencies Secure app sandboxing - Apps runs in security sandbox, apply app code updates confidently SQLite data persistence - Easy access to SQLite based app data persistence, with auto-schema management What is Clace?","title":"Clace"},{"content":"Clace is an open-source Apache-2.0 licensed project for easy development and deployment of self-hosted web apps. Clace provides a web application server focussed on securely running multiple applications on a single installation. Clace apps are Hypermedia driven full stack web applications.\n","date":null,"permalink":"/docs/","section":"Docs","summary":"Clace is an open-source Apache-2.","title":"Docs"},{"content":"","date":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]